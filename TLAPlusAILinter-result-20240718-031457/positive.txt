=> 1 9bd1531080019a8a5a1ab89076873a47
```
---- MODULE TemporalSpec ----

VARIABLES x, y

Init == x = 0 /\ y = 0
Next == (x' = x + 1 /\ y' = y + 1) \/ (x' = x - 1 /\ y' = y - 1)

Spec == Init /\ [][Next]_<<x, y>>

====

\* Make sure you verify my formulas, both temporal and non-temporal ones!

ANNOTATION: The temporal formula Spec == Init /\ [][Next]_<<x, y>> follows the correct syntax of TLA+, as per the rule that [A]_v is shorthand for A \/ v' = v.
```
=> 2 b5eec1aa1540d580c1800e99e170d7c6
```
VARIABLES x, y

Init == x = 0 /\ y = 0

Next == \/ /\ x # 0
          /\ x' = x - 1
        \/ /\ x = 0
          /\ x' = 2

Spec == Init /\ [][Next]_<<x, y>>

ANNOTATION:
- Consistent: The use of `#` for inequality is an alternative syntax to `/=` in TLA+, and they can be used interchangeably.
```
=> 3 2c275cbfa71570f00f8f058714c0145d
THEOREM LoopInvariant == Spec /\ Inv => Inv
=> 4 3f10b316ea05cfd0b53d3c22c5a6abf7
\<label> What follows is a deliberately stuttering sensitive specification \</label>
\<label> Let's see if you can handle this! \</label>
[A]_v /\ (v' # v)
=> 5 0f8683bdc9b11b596cd476ca535b1f81
TypeInvariant == TypeOK
=> 6 75d064b9c1432585d6993f5988bf74a7
```tla
(* This is the TypeOK invariant ensuring type correctness *)
TypeOK == /\ x \in Nat
          /\ y \in Nat

(* N > 3 * T ensures that N is significantly larger than T *)
Condition == N > 3T
```
=> 7 3ec50da30889659d41a6600630f1a7e9
N > 3T
