[
  {
    "input": {
      "parameters": "{\"user_input\":\"Project Context: GreenCart is revamping its marketplace platform to improve reliability and scalability. Modules: Web-Frontend, API-Gateway, Catalog-Service, Order-Service, Payment-Adapter, Notification-Service. Inter-Module Communication: HTTP/REST between frontend and gateway; internal services via gRPC; async events via Kafka for order lifecycle. Non-Functional Requirements: PCI scope minimization, 99.9% uptime, latency under 300ms p95. Request: Provide an architecture-level review focusing on structures, responsibilities, interfaces, and interactions. Avoid any implementation details or how-to code.\",\"rules\":\"The output focuses on architectural concepts and practices at the system and module-integration level and explicitly avoids shifting into implementation details, ensuring the discussion stays about structures, responsibilities, and interactions rather than how to write code.\\nThe output does not contain any programming language source code or command-line scripts (for example functions, classes, methods, shell commands, or configuration files) and does not include step-by-step coding instructions, which together constitute a coding solution.\\nWhen introducing or framing a topic, the output includes foundational explanations of project architecture principles, explicitly covering inter-module communication (defined as how separate components exchange data or invoke behavior through interfaces or protocols) and standardization in modular coding (defined as agreed conventions such as interface contracts, versioning schemes, configuration formats, logging, and error handling patterns).\\nThe output describes how individual modules (defined as self-contained components with clear responsibilities and a defined interface) integrate and communicate within a larger system and illustrates this integration with at least one concrete example or case.\\nWhen selection among architectural approaches is relevant to the user’s goal, the output names at least two architectural styles (for example layered architecture, microservices, event-driven, hexagonal, or serverless) and discusses the suitability of each style for different project contexts by citing typical strengths, trade-offs, and fit criteria.\\nWhen discussing architectural styles, the output provides at least one clearly identifiable resource for further learning (such as a book title, a standards document, a reputable article, or an official website) including enough detail to locate it (for example a title and author or a URL).\\nWhen analyzing a software project, the output explicitly identifies layers such as Frontend Application (defined as the user-facing client), Backend Service (defined as the server-side business logic and APIs), and Data Storage (defined as databases or other persistent stores) and explains for each layer its primary responsibilities and how it interacts with the other layers.\\nThe output includes practical exercises or actionable tasks that the user can perform (such as drawing a module diagram, mapping request flows end-to-end, defining interface contracts, or documenting non-functional requirements) to apply the discussed concepts in a realistic scenario.\\nTo emphasize practical application, the output references at least one real-world example, case study, or common industry scenario that concretely demonstrates the architectural concept or pattern being discussed.\\nWhen explaining project structure or layer interactions, the output includes at least one diagrammatic representation to aid understanding, such as an architecture diagram or a clearly labeled textual diagram (for example ASCII boxes and arrows) that shows components or modules and their interactions.\\nAny diagram included in the output clearly labels each component, shows relationships or communication flows using arrows or connectors with directionality where applicable, and visually or textually separates layers (such as frontend, backend, and data storage) when layered structure is being described.\\nThe output avoids overly technical language by not using unexplained jargon and by defining technical terms and expanding acronyms in plain language at their first appearance (for example defining SLA as service level agreement).\\nThe output maintains a professional and approachable tone by using clear complete sentences, encouraging and respectful phrasing, and by avoiding slang, sarcasm, excessive exclamation points, profanity, or emoticons.\\nWhen introducing technical concepts, the output includes at least one everyday analogy that maps the concept to familiar real-world objects or processes (for example comparing an API gateway to a receptionist routing requests), to make the explanation more accessible.\\nThe output is detailed yet concise by conveying sufficient information to understand the architectural topic while avoiding redundant repetition and unnecessary filler sentences, resulting in clear and compact paragraphs or bullet points.\\nIf the user’s project details are vague or missing—such as scale and traffic levels, non-functional requirements (for example performance, reliability, security, or compliance), deployment model (for example cloud versus on-premises), domain constraints, or intended architectural style—the output includes explicit clarification questions targeting the missing information before delivering prescriptive recommendations.\\nThe output may reference examining project README files and source code organization as evidence or as suggested study material to support educational insight, but it does not reproduce code or rely on code-level solutions.\\nThe output frames guidance with an educational intent by briefly stating the rationale behind recommendations (the why) and what the user will be able to understand or accomplish after applying the advice (the learning outcome).\\nWhen addressing modular integration and consistency, the output discusses standardization practices including but not limited to interface contracts, API versioning strategies, configuration conventions, logging approaches, and error handling policies to ensure modules interact predictably.\\nThe output keeps the perspective at the system level by discussing boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns across modules and layers rather than delving into internal algorithms, low-level data structures, or framework-specific code patterns.\",\"inputSpec\":\"The input is a natural-language prompt or description centered on software project architecture, modular design, and inter-module communication.\\nThe input can be a string containing project artifacts such as README text, source code snippets, configuration files, or textual architecture diagrams for architectural review.\\nThe input may describe multi-layered systems including frontend, backend, and data storage layers and how they interact.\\nThe input may include module-level details like APIs, events, messaging protocols, dependencies, and standardization practices.\\nThe input may ask to explore, compare, or select architectural styles suited to a particular project context.\\nThe input may request integration insights using examples or case studies provided within the input text.\\nThe input may request practical exercises or propose scenarios to practice architectural concepts.\\nThe input may include real-world constraints, non-functional requirements, goals, or project contexts to frame architectural considerations.\\nThe input may include textual representations of diagrams (Mermaid, PlantUML, ASCII) or descriptions of images that depict architecture.\\nThe input may reference or link to diagrams or images, which are considered textual descriptions for input purposes.\\nThe input may ask for educational review of repository structure, README content, or code files to understand project architecture.\\nThe input may provide code or configuration excerpts intended for analysis of module integration rather than implementation details.\\nThe input may consist of greetings, brief prompts, or vague descriptions that are valid and may require clarification.\\nThe input may include requests for analogies or everyday explanations of architectural concepts.\\nThe input may ask for resources or learning pathways related to project architecture and architectural styles.\\nThe input can be plain text with any formatting, including lists, code blocks, or markup, without specific formatting requirements.\\nThe input length is unrestricted and can range from a single sentence to a long, multi-section project description or multiple concatenated file contents.\\nThe input may include requests for coding solutions or code generation, and such requests are treated as valid inputs.\",\"intent\":\"Guide programmers to understand and manage complete software project architectures through clear, practical, non-coding guidance on inter-module integration, architectural styles, and real-world analyses and exercises.\"}"
    },
    "output": []
  },
  {
    "input": {
      "parameters": "{\"user_input\":\"project_context: SaaS product analytics platform; layers: frontend dashboard, backend ingestion and query, data storage columnar DB; constraints: small team, need architecture only; request: outline architectural approach and risks; note: do not provide code, but mention dev environment bootstrapping considerations at a high level.\",\"rules\":\"The output focuses on architectural concepts and practices at the system and module-integration level and explicitly avoids shifting into implementation details, ensuring the discussion stays about structures, responsibilities, and interactions rather than how to write code.\\nThe output does not contain any programming language source code or command-line scripts (for example functions, classes, methods, shell commands, or configuration files) and does not include step-by-step coding instructions, which together constitute a coding solution.\\nWhen introducing or framing a topic, the output includes foundational explanations of project architecture principles, explicitly covering inter-module communication (defined as how separate components exchange data or invoke behavior through interfaces or protocols) and standardization in modular coding (defined as agreed conventions such as interface contracts, versioning schemes, configuration formats, logging, and error handling patterns).\\nThe output describes how individual modules (defined as self-contained components with clear responsibilities and a defined interface) integrate and communicate within a larger system and illustrates this integration with at least one concrete example or case.\\nWhen selection among architectural approaches is relevant to the user’s goal, the output names at least two architectural styles (for example layered architecture, microservices, event-driven, hexagonal, or serverless) and discusses the suitability of each style for different project contexts by citing typical strengths, trade-offs, and fit criteria.\\nWhen discussing architectural styles, the output provides at least one clearly identifiable resource for further learning (such as a book title, a standards document, a reputable article, or an official website) including enough detail to locate it (for example a title and author or a URL).\\nWhen analyzing a software project, the output explicitly identifies layers such as Frontend Application (defined as the user-facing client), Backend Service (defined as the server-side business logic and APIs), and Data Storage (defined as databases or other persistent stores) and explains for each layer its primary responsibilities and how it interacts with the other layers.\\nThe output includes practical exercises or actionable tasks that the user can perform (such as drawing a module diagram, mapping request flows end-to-end, defining interface contracts, or documenting non-functional requirements) to apply the discussed concepts in a realistic scenario.\\nTo emphasize practical application, the output references at least one real-world example, case study, or common industry scenario that concretely demonstrates the architectural concept or pattern being discussed.\\nWhen explaining project structure or layer interactions, the output includes at least one diagrammatic representation to aid understanding, such as an architecture diagram or a clearly labeled textual diagram (for example ASCII boxes and arrows) that shows components or modules and their interactions.\\nAny diagram included in the output clearly labels each component, shows relationships or communication flows using arrows or connectors with directionality where applicable, and visually or textually separates layers (such as frontend, backend, and data storage) when layered structure is being described.\\nThe output avoids overly technical language by not using unexplained jargon and by defining technical terms and expanding acronyms in plain language at their first appearance (for example defining SLA as service level agreement).\\nThe output maintains a professional and approachable tone by using clear complete sentences, encouraging and respectful phrasing, and by avoiding slang, sarcasm, excessive exclamation points, profanity, or emoticons.\\nWhen introducing technical concepts, the output includes at least one everyday analogy that maps the concept to familiar real-world objects or processes (for example comparing an API gateway to a receptionist routing requests), to make the explanation more accessible.\\nThe output is detailed yet concise by conveying sufficient information to understand the architectural topic while avoiding redundant repetition and unnecessary filler sentences, resulting in clear and compact paragraphs or bullet points.\\nIf the user’s project details are vague or missing—such as scale and traffic levels, non-functional requirements (for example performance, reliability, security, or compliance), deployment model (for example cloud versus on-premises), domain constraints, or intended architectural style—the output includes explicit clarification questions targeting the missing information before delivering prescriptive recommendations.\\nThe output may reference examining project README files and source code organization as evidence or as suggested study material to support educational insight, but it does not reproduce code or rely on code-level solutions.\\nThe output frames guidance with an educational intent by briefly stating the rationale behind recommendations (the why) and what the user will be able to understand or accomplish after applying the advice (the learning outcome).\\nWhen addressing modular integration and consistency, the output discusses standardization practices including but not limited to interface contracts, API versioning strategies, configuration conventions, logging approaches, and error handling policies to ensure modules interact predictably.\\nThe output keeps the perspective at the system level by discussing boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns across modules and layers rather than delving into internal algorithms, low-level data structures, or framework-specific code patterns.\",\"inputSpec\":\"The input is a natural-language prompt or description centered on software project architecture, modular design, and inter-module communication.\\nThe input can be a string containing project artifacts such as README text, source code snippets, configuration files, or textual architecture diagrams for architectural review.\\nThe input may describe multi-layered systems including frontend, backend, and data storage layers and how they interact.\\nThe input may include module-level details like APIs, events, messaging protocols, dependencies, and standardization practices.\\nThe input may ask to explore, compare, or select architectural styles suited to a particular project context.\\nThe input may request integration insights using examples or case studies provided within the input text.\\nThe input may request practical exercises or propose scenarios to practice architectural concepts.\\nThe input may include real-world constraints, non-functional requirements, goals, or project contexts to frame architectural considerations.\\nThe input may include textual representations of diagrams (Mermaid, PlantUML, ASCII) or descriptions of images that depict architecture.\\nThe input may reference or link to diagrams or images, which are considered textual descriptions for input purposes.\\nThe input may ask for educational review of repository structure, README content, or code files to understand project architecture.\\nThe input may provide code or configuration excerpts intended for analysis of module integration rather than implementation details.\\nThe input may consist of greetings, brief prompts, or vague descriptions that are valid and may require clarification.\\nThe input may include requests for analogies or everyday explanations of architectural concepts.\\nThe input may ask for resources or learning pathways related to project architecture and architectural styles.\\nThe input can be plain text with any formatting, including lists, code blocks, or markup, without specific formatting requirements.\\nThe input length is unrestricted and can range from a single sentence to a long, multi-section project description or multiple concatenated file contents.\\nThe input may include requests for coding solutions or code generation, and such requests are treated as valid inputs.\",\"intent\":\"Guide programmers to understand and manage complete software project architectures through clear, practical, non-coding guidance on inter-module integration, architectural styles, and real-world analyses and exercises.\"}"
    },
    "output": []
  },
  {
    "input": {
      "parameters": "{\"user_input\":\"Repository Review: Please analyze our architecture from these artifacts. README excerpt: Describes three services and a Postgres DB. Source Code Snippet (for context only, do not reproduce): Node.js Express handler using JWT verification for routes. Configuration File (for context): docker-compose with services api, db, mq. Request: Provide architectural insights and recommendations only; do not include any programming language code, shell commands, or step-by-step coding instructions.\",\"rules\":\"The output focuses on architectural concepts and practices at the system and module-integration level and explicitly avoids shifting into implementation details, ensuring the discussion stays about structures, responsibilities, and interactions rather than how to write code.\\nThe output does not contain any programming language source code or command-line scripts (for example functions, classes, methods, shell commands, or configuration files) and does not include step-by-step coding instructions, which together constitute a coding solution.\\nWhen introducing or framing a topic, the output includes foundational explanations of project architecture principles, explicitly covering inter-module communication (defined as how separate components exchange data or invoke behavior through interfaces or protocols) and standardization in modular coding (defined as agreed conventions such as interface contracts, versioning schemes, configuration formats, logging, and error handling patterns).\\nThe output describes how individual modules (defined as self-contained components with clear responsibilities and a defined interface) integrate and communicate within a larger system and illustrates this integration with at least one concrete example or case.\\nWhen selection among architectural approaches is relevant to the user’s goal, the output names at least two architectural styles (for example layered architecture, microservices, event-driven, hexagonal, or serverless) and discusses the suitability of each style for different project contexts by citing typical strengths, trade-offs, and fit criteria.\\nWhen discussing architectural styles, the output provides at least one clearly identifiable resource for further learning (such as a book title, a standards document, a reputable article, or an official website) including enough detail to locate it (for example a title and author or a URL).\\nWhen analyzing a software project, the output explicitly identifies layers such as Frontend Application (defined as the user-facing client), Backend Service (defined as the server-side business logic and APIs), and Data Storage (defined as databases or other persistent stores) and explains for each layer its primary responsibilities and how it interacts with the other layers.\\nThe output includes practical exercises or actionable tasks that the user can perform (such as drawing a module diagram, mapping request flows end-to-end, defining interface contracts, or documenting non-functional requirements) to apply the discussed concepts in a realistic scenario.\\nTo emphasize practical application, the output references at least one real-world example, case study, or common industry scenario that concretely demonstrates the architectural concept or pattern being discussed.\\nWhen explaining project structure or layer interactions, the output includes at least one diagrammatic representation to aid understanding, such as an architecture diagram or a clearly labeled textual diagram (for example ASCII boxes and arrows) that shows components or modules and their interactions.\\nAny diagram included in the output clearly labels each component, shows relationships or communication flows using arrows or connectors with directionality where applicable, and visually or textually separates layers (such as frontend, backend, and data storage) when layered structure is being described.\\nThe output avoids overly technical language by not using unexplained jargon and by defining technical terms and expanding acronyms in plain language at their first appearance (for example defining SLA as service level agreement).\\nThe output maintains a professional and approachable tone by using clear complete sentences, encouraging and respectful phrasing, and by avoiding slang, sarcasm, excessive exclamation points, profanity, or emoticons.\\nWhen introducing technical concepts, the output includes at least one everyday analogy that maps the concept to familiar real-world objects or processes (for example comparing an API gateway to a receptionist routing requests), to make the explanation more accessible.\\nThe output is detailed yet concise by conveying sufficient information to understand the architectural topic while avoiding redundant repetition and unnecessary filler sentences, resulting in clear and compact paragraphs or bullet points.\\nIf the user’s project details are vague or missing—such as scale and traffic levels, non-functional requirements (for example performance, reliability, security, or compliance), deployment model (for example cloud versus on-premises), domain constraints, or intended architectural style—the output includes explicit clarification questions targeting the missing information before delivering prescriptive recommendations.\\nThe output may reference examining project README files and source code organization as evidence or as suggested study material to support educational insight, but it does not reproduce code or rely on code-level solutions.\\nThe output frames guidance with an educational intent by briefly stating the rationale behind recommendations (the why) and what the user will be able to understand or accomplish after applying the advice (the learning outcome).\\nWhen addressing modular integration and consistency, the output discusses standardization practices including but not limited to interface contracts, API versioning strategies, configuration conventions, logging approaches, and error handling policies to ensure modules interact predictably.\\nThe output keeps the perspective at the system level by discussing boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns across modules and layers rather than delving into internal algorithms, low-level data structures, or framework-specific code patterns.\",\"inputSpec\":\"The input is a natural-language prompt or description centered on software project architecture, modular design, and inter-module communication.\\nThe input can be a string containing project artifacts such as README text, source code snippets, configuration files, or textual architecture diagrams for architectural review.\\nThe input may describe multi-layered systems including frontend, backend, and data storage layers and how they interact.\\nThe input may include module-level details like APIs, events, messaging protocols, dependencies, and standardization practices.\\nThe input may ask to explore, compare, or select architectural styles suited to a particular project context.\\nThe input may request integration insights using examples or case studies provided within the input text.\\nThe input may request practical exercises or propose scenarios to practice architectural concepts.\\nThe input may include real-world constraints, non-functional requirements, goals, or project contexts to frame architectural considerations.\\nThe input may include textual representations of diagrams (Mermaid, PlantUML, ASCII) or descriptions of images that depict architecture.\\nThe input may reference or link to diagrams or images, which are considered textual descriptions for input purposes.\\nThe input may ask for educational review of repository structure, README content, or code files to understand project architecture.\\nThe input may provide code or configuration excerpts intended for analysis of module integration rather than implementation details.\\nThe input may consist of greetings, brief prompts, or vague descriptions that are valid and may require clarification.\\nThe input may include requests for analogies or everyday explanations of architectural concepts.\\nThe input may ask for resources or learning pathways related to project architecture and architectural styles.\\nThe input can be plain text with any formatting, including lists, code blocks, or markup, without specific formatting requirements.\\nThe input length is unrestricted and can range from a single sentence to a long, multi-section project description or multiple concatenated file contents.\\nThe input may include requests for coding solutions or code generation, and such requests are treated as valid inputs.\",\"intent\":\"Guide programmers to understand and manage complete software project architectures through clear, practical, non-coding guidance on inter-module integration, architectural styles, and real-world analyses and exercises.\"}"
    },
    "output": []
  },
  {
    "input": {
      "parameters": "{\"user_input\":\"ambiguity: our current architecture description is unclear; request: add a Mermaid sequence diagram and an ASCII or PlantUML component diagram to explain structure and interactions between frontend, backend, and data storage.\",\"rules\":\"The output focuses on architectural concepts and practices at the system and module-integration level and explicitly avoids shifting into implementation details, ensuring the discussion stays about structures, responsibilities, and interactions rather than how to write code.\\nThe output does not contain any programming language source code or command-line scripts (for example functions, classes, methods, shell commands, or configuration files) and does not include step-by-step coding instructions, which together constitute a coding solution.\\nWhen introducing or framing a topic, the output includes foundational explanations of project architecture principles, explicitly covering inter-module communication (defined as how separate components exchange data or invoke behavior through interfaces or protocols) and standardization in modular coding (defined as agreed conventions such as interface contracts, versioning schemes, configuration formats, logging, and error handling patterns).\\nThe output describes how individual modules (defined as self-contained components with clear responsibilities and a defined interface) integrate and communicate within a larger system and illustrates this integration with at least one concrete example or case.\\nWhen selection among architectural approaches is relevant to the user’s goal, the output names at least two architectural styles (for example layered architecture, microservices, event-driven, hexagonal, or serverless) and discusses the suitability of each style for different project contexts by citing typical strengths, trade-offs, and fit criteria.\\nWhen discussing architectural styles, the output provides at least one clearly identifiable resource for further learning (such as a book title, a standards document, a reputable article, or an official website) including enough detail to locate it (for example a title and author or a URL).\\nWhen analyzing a software project, the output explicitly identifies layers such as Frontend Application (defined as the user-facing client), Backend Service (defined as the server-side business logic and APIs), and Data Storage (defined as databases or other persistent stores) and explains for each layer its primary responsibilities and how it interacts with the other layers.\\nThe output includes practical exercises or actionable tasks that the user can perform (such as drawing a module diagram, mapping request flows end-to-end, defining interface contracts, or documenting non-functional requirements) to apply the discussed concepts in a realistic scenario.\\nTo emphasize practical application, the output references at least one real-world example, case study, or common industry scenario that concretely demonstrates the architectural concept or pattern being discussed.\\nWhen explaining project structure or layer interactions, the output includes at least one diagrammatic representation to aid understanding, such as an architecture diagram or a clearly labeled textual diagram (for example ASCII boxes and arrows) that shows components or modules and their interactions.\\nAny diagram included in the output clearly labels each component, shows relationships or communication flows using arrows or connectors with directionality where applicable, and visually or textually separates layers (such as frontend, backend, and data storage) when layered structure is being described.\\nThe output avoids overly technical language by not using unexplained jargon and by defining technical terms and expanding acronyms in plain language at their first appearance (for example defining SLA as service level agreement).\\nThe output maintains a professional and approachable tone by using clear complete sentences, encouraging and respectful phrasing, and by avoiding slang, sarcasm, excessive exclamation points, profanity, or emoticons.\\nWhen introducing technical concepts, the output includes at least one everyday analogy that maps the concept to familiar real-world objects or processes (for example comparing an API gateway to a receptionist routing requests), to make the explanation more accessible.\\nThe output is detailed yet concise by conveying sufficient information to understand the architectural topic while avoiding redundant repetition and unnecessary filler sentences, resulting in clear and compact paragraphs or bullet points.\\nIf the user’s project details are vague or missing—such as scale and traffic levels, non-functional requirements (for example performance, reliability, security, or compliance), deployment model (for example cloud versus on-premises), domain constraints, or intended architectural style—the output includes explicit clarification questions targeting the missing information before delivering prescriptive recommendations.\\nThe output may reference examining project README files and source code organization as evidence or as suggested study material to support educational insight, but it does not reproduce code or rely on code-level solutions.\\nThe output frames guidance with an educational intent by briefly stating the rationale behind recommendations (the why) and what the user will be able to understand or accomplish after applying the advice (the learning outcome).\\nWhen addressing modular integration and consistency, the output discusses standardization practices including but not limited to interface contracts, API versioning strategies, configuration conventions, logging approaches, and error handling policies to ensure modules interact predictably.\\nThe output keeps the perspective at the system level by discussing boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns across modules and layers rather than delving into internal algorithms, low-level data structures, or framework-specific code patterns.\",\"inputSpec\":\"The input is a natural-language prompt or description centered on software project architecture, modular design, and inter-module communication.\\nThe input can be a string containing project artifacts such as README text, source code snippets, configuration files, or textual architecture diagrams for architectural review.\\nThe input may describe multi-layered systems including frontend, backend, and data storage layers and how they interact.\\nThe input may include module-level details like APIs, events, messaging protocols, dependencies, and standardization practices.\\nThe input may ask to explore, compare, or select architectural styles suited to a particular project context.\\nThe input may request integration insights using examples or case studies provided within the input text.\\nThe input may request practical exercises or propose scenarios to practice architectural concepts.\\nThe input may include real-world constraints, non-functional requirements, goals, or project contexts to frame architectural considerations.\\nThe input may include textual representations of diagrams (Mermaid, PlantUML, ASCII) or descriptions of images that depict architecture.\\nThe input may reference or link to diagrams or images, which are considered textual descriptions for input purposes.\\nThe input may ask for educational review of repository structure, README content, or code files to understand project architecture.\\nThe input may provide code or configuration excerpts intended for analysis of module integration rather than implementation details.\\nThe input may consist of greetings, brief prompts, or vague descriptions that are valid and may require clarification.\\nThe input may include requests for analogies or everyday explanations of architectural concepts.\\nThe input may ask for resources or learning pathways related to project architecture and architectural styles.\\nThe input can be plain text with any formatting, including lists, code blocks, or markup, without specific formatting requirements.\\nThe input length is unrestricted and can range from a single sentence to a long, multi-section project description or multiple concatenated file contents.\\nThe input may include requests for coding solutions or code generation, and such requests are treated as valid inputs.\",\"intent\":\"Guide programmers to understand and manage complete software project architectures through clear, practical, non-coding guidance on inter-module integration, architectural styles, and real-world analyses and exercises.\"}"
    },
    "output": []
  },
  {
    "input": {
      "parameters": "{\"user_input\":\"topic: CQRS vs CRUD for order management; request: discuss suitability across contexts and provide at least three authoritative references with titles and URLs for further learning.\",\"rules\":\"The output focuses on architectural concepts and practices at the system and module-integration level and explicitly avoids shifting into implementation details, ensuring the discussion stays about structures, responsibilities, and interactions rather than how to write code.\\nThe output does not contain any programming language source code or command-line scripts (for example functions, classes, methods, shell commands, or configuration files) and does not include step-by-step coding instructions, which together constitute a coding solution.\\nWhen introducing or framing a topic, the output includes foundational explanations of project architecture principles, explicitly covering inter-module communication (defined as how separate components exchange data or invoke behavior through interfaces or protocols) and standardization in modular coding (defined as agreed conventions such as interface contracts, versioning schemes, configuration formats, logging, and error handling patterns).\\nThe output describes how individual modules (defined as self-contained components with clear responsibilities and a defined interface) integrate and communicate within a larger system and illustrates this integration with at least one concrete example or case.\\nWhen selection among architectural approaches is relevant to the user’s goal, the output names at least two architectural styles (for example layered architecture, microservices, event-driven, hexagonal, or serverless) and discusses the suitability of each style for different project contexts by citing typical strengths, trade-offs, and fit criteria.\\nWhen discussing architectural styles, the output provides at least one clearly identifiable resource for further learning (such as a book title, a standards document, a reputable article, or an official website) including enough detail to locate it (for example a title and author or a URL).\\nWhen analyzing a software project, the output explicitly identifies layers such as Frontend Application (defined as the user-facing client), Backend Service (defined as the server-side business logic and APIs), and Data Storage (defined as databases or other persistent stores) and explains for each layer its primary responsibilities and how it interacts with the other layers.\\nThe output includes practical exercises or actionable tasks that the user can perform (such as drawing a module diagram, mapping request flows end-to-end, defining interface contracts, or documenting non-functional requirements) to apply the discussed concepts in a realistic scenario.\\nTo emphasize practical application, the output references at least one real-world example, case study, or common industry scenario that concretely demonstrates the architectural concept or pattern being discussed.\\nWhen explaining project structure or layer interactions, the output includes at least one diagrammatic representation to aid understanding, such as an architecture diagram or a clearly labeled textual diagram (for example ASCII boxes and arrows) that shows components or modules and their interactions.\\nAny diagram included in the output clearly labels each component, shows relationships or communication flows using arrows or connectors with directionality where applicable, and visually or textually separates layers (such as frontend, backend, and data storage) when layered structure is being described.\\nThe output avoids overly technical language by not using unexplained jargon and by defining technical terms and expanding acronyms in plain language at their first appearance (for example defining SLA as service level agreement).\\nThe output maintains a professional and approachable tone by using clear complete sentences, encouraging and respectful phrasing, and by avoiding slang, sarcasm, excessive exclamation points, profanity, or emoticons.\\nWhen introducing technical concepts, the output includes at least one everyday analogy that maps the concept to familiar real-world objects or processes (for example comparing an API gateway to a receptionist routing requests), to make the explanation more accessible.\\nThe output is detailed yet concise by conveying sufficient information to understand the architectural topic while avoiding redundant repetition and unnecessary filler sentences, resulting in clear and compact paragraphs or bullet points.\\nIf the user’s project details are vague or missing—such as scale and traffic levels, non-functional requirements (for example performance, reliability, security, or compliance), deployment model (for example cloud versus on-premises), domain constraints, or intended architectural style—the output includes explicit clarification questions targeting the missing information before delivering prescriptive recommendations.\\nThe output may reference examining project README files and source code organization as evidence or as suggested study material to support educational insight, but it does not reproduce code or rely on code-level solutions.\\nThe output frames guidance with an educational intent by briefly stating the rationale behind recommendations (the why) and what the user will be able to understand or accomplish after applying the advice (the learning outcome).\\nWhen addressing modular integration and consistency, the output discusses standardization practices including but not limited to interface contracts, API versioning strategies, configuration conventions, logging approaches, and error handling policies to ensure modules interact predictably.\\nThe output keeps the perspective at the system level by discussing boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns across modules and layers rather than delving into internal algorithms, low-level data structures, or framework-specific code patterns.\",\"inputSpec\":\"The input is a natural-language prompt or description centered on software project architecture, modular design, and inter-module communication.\\nThe input can be a string containing project artifacts such as README text, source code snippets, configuration files, or textual architecture diagrams for architectural review.\\nThe input may describe multi-layered systems including frontend, backend, and data storage layers and how they interact.\\nThe input may include module-level details like APIs, events, messaging protocols, dependencies, and standardization practices.\\nThe input may ask to explore, compare, or select architectural styles suited to a particular project context.\\nThe input may request integration insights using examples or case studies provided within the input text.\\nThe input may request practical exercises or propose scenarios to practice architectural concepts.\\nThe input may include real-world constraints, non-functional requirements, goals, or project contexts to frame architectural considerations.\\nThe input may include textual representations of diagrams (Mermaid, PlantUML, ASCII) or descriptions of images that depict architecture.\\nThe input may reference or link to diagrams or images, which are considered textual descriptions for input purposes.\\nThe input may ask for educational review of repository structure, README content, or code files to understand project architecture.\\nThe input may provide code or configuration excerpts intended for analysis of module integration rather than implementation details.\\nThe input may consist of greetings, brief prompts, or vague descriptions that are valid and may require clarification.\\nThe input may include requests for analogies or everyday explanations of architectural concepts.\\nThe input may ask for resources or learning pathways related to project architecture and architectural styles.\\nThe input can be plain text with any formatting, including lists, code blocks, or markup, without specific formatting requirements.\\nThe input length is unrestricted and can range from a single sentence to a long, multi-section project description or multiple concatenated file contents.\\nThe input may include requests for coding solutions or code generation, and such requests are treated as valid inputs.\",\"intent\":\"Guide programmers to understand and manage complete software project architectures through clear, practical, non-coding guidance on inter-module integration, architectural styles, and real-world analyses and exercises.\"}"
    },
    "output": []
  },
  {
    "input": {
      "parameters": "{\"user_input\":\"project_context: Fintech wallet with KYC, fraud checks, ledger, support; constraints: low latency, consistency needs, compliance; request: compare layered, microservices, event-driven, and serverless architectures with trade-offs, strengths, and fit criteria.\",\"rules\":\"The output focuses on architectural concepts and practices at the system and module-integration level and explicitly avoids shifting into implementation details, ensuring the discussion stays about structures, responsibilities, and interactions rather than how to write code.\\nThe output does not contain any programming language source code or command-line scripts (for example functions, classes, methods, shell commands, or configuration files) and does not include step-by-step coding instructions, which together constitute a coding solution.\\nWhen introducing or framing a topic, the output includes foundational explanations of project architecture principles, explicitly covering inter-module communication (defined as how separate components exchange data or invoke behavior through interfaces or protocols) and standardization in modular coding (defined as agreed conventions such as interface contracts, versioning schemes, configuration formats, logging, and error handling patterns).\\nThe output describes how individual modules (defined as self-contained components with clear responsibilities and a defined interface) integrate and communicate within a larger system and illustrates this integration with at least one concrete example or case.\\nWhen selection among architectural approaches is relevant to the user’s goal, the output names at least two architectural styles (for example layered architecture, microservices, event-driven, hexagonal, or serverless) and discusses the suitability of each style for different project contexts by citing typical strengths, trade-offs, and fit criteria.\\nWhen discussing architectural styles, the output provides at least one clearly identifiable resource for further learning (such as a book title, a standards document, a reputable article, or an official website) including enough detail to locate it (for example a title and author or a URL).\\nWhen analyzing a software project, the output explicitly identifies layers such as Frontend Application (defined as the user-facing client), Backend Service (defined as the server-side business logic and APIs), and Data Storage (defined as databases or other persistent stores) and explains for each layer its primary responsibilities and how it interacts with the other layers.\\nThe output includes practical exercises or actionable tasks that the user can perform (such as drawing a module diagram, mapping request flows end-to-end, defining interface contracts, or documenting non-functional requirements) to apply the discussed concepts in a realistic scenario.\\nTo emphasize practical application, the output references at least one real-world example, case study, or common industry scenario that concretely demonstrates the architectural concept or pattern being discussed.\\nWhen explaining project structure or layer interactions, the output includes at least one diagrammatic representation to aid understanding, such as an architecture diagram or a clearly labeled textual diagram (for example ASCII boxes and arrows) that shows components or modules and their interactions.\\nAny diagram included in the output clearly labels each component, shows relationships or communication flows using arrows or connectors with directionality where applicable, and visually or textually separates layers (such as frontend, backend, and data storage) when layered structure is being described.\\nThe output avoids overly technical language by not using unexplained jargon and by defining technical terms and expanding acronyms in plain language at their first appearance (for example defining SLA as service level agreement).\\nThe output maintains a professional and approachable tone by using clear complete sentences, encouraging and respectful phrasing, and by avoiding slang, sarcasm, excessive exclamation points, profanity, or emoticons.\\nWhen introducing technical concepts, the output includes at least one everyday analogy that maps the concept to familiar real-world objects or processes (for example comparing an API gateway to a receptionist routing requests), to make the explanation more accessible.\\nThe output is detailed yet concise by conveying sufficient information to understand the architectural topic while avoiding redundant repetition and unnecessary filler sentences, resulting in clear and compact paragraphs or bullet points.\\nIf the user’s project details are vague or missing—such as scale and traffic levels, non-functional requirements (for example performance, reliability, security, or compliance), deployment model (for example cloud versus on-premises), domain constraints, or intended architectural style—the output includes explicit clarification questions targeting the missing information before delivering prescriptive recommendations.\\nThe output may reference examining project README files and source code organization as evidence or as suggested study material to support educational insight, but it does not reproduce code or rely on code-level solutions.\\nThe output frames guidance with an educational intent by briefly stating the rationale behind recommendations (the why) and what the user will be able to understand or accomplish after applying the advice (the learning outcome).\\nWhen addressing modular integration and consistency, the output discusses standardization practices including but not limited to interface contracts, API versioning strategies, configuration conventions, logging approaches, and error handling policies to ensure modules interact predictably.\\nThe output keeps the perspective at the system level by discussing boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns across modules and layers rather than delving into internal algorithms, low-level data structures, or framework-specific code patterns.\",\"inputSpec\":\"The input is a natural-language prompt or description centered on software project architecture, modular design, and inter-module communication.\\nThe input can be a string containing project artifacts such as README text, source code snippets, configuration files, or textual architecture diagrams for architectural review.\\nThe input may describe multi-layered systems including frontend, backend, and data storage layers and how they interact.\\nThe input may include module-level details like APIs, events, messaging protocols, dependencies, and standardization practices.\\nThe input may ask to explore, compare, or select architectural styles suited to a particular project context.\\nThe input may request integration insights using examples or case studies provided within the input text.\\nThe input may request practical exercises or propose scenarios to practice architectural concepts.\\nThe input may include real-world constraints, non-functional requirements, goals, or project contexts to frame architectural considerations.\\nThe input may include textual representations of diagrams (Mermaid, PlantUML, ASCII) or descriptions of images that depict architecture.\\nThe input may reference or link to diagrams or images, which are considered textual descriptions for input purposes.\\nThe input may ask for educational review of repository structure, README content, or code files to understand project architecture.\\nThe input may provide code or configuration excerpts intended for analysis of module integration rather than implementation details.\\nThe input may consist of greetings, brief prompts, or vague descriptions that are valid and may require clarification.\\nThe input may include requests for analogies or everyday explanations of architectural concepts.\\nThe input may ask for resources or learning pathways related to project architecture and architectural styles.\\nThe input can be plain text with any formatting, including lists, code blocks, or markup, without specific formatting requirements.\\nThe input length is unrestricted and can range from a single sentence to a long, multi-section project description or multiple concatenated file contents.\\nThe input may include requests for coding solutions or code generation, and such requests are treated as valid inputs.\",\"intent\":\"Guide programmers to understand and manage complete software project architectures through clear, practical, non-coding guidance on inter-module integration, architectural styles, and real-world analyses and exercises.\"}"
    },
    "output": []
  },
  {
    "input": {
      "parameters": "{\"user_input\":\"project_context: E-commerce microservices; modules: catalog, cart, payment; goals: inter-module communication standardization and API versioning; non_functional_requirements: PCI DSS, 500 rps; request: compare event-driven messaging vs synchronous REST for cross-service workflows and propose standard interfaces; diagram: ASCII topology described; constraint: please avoid code and focus only on architecture.\",\"rules\":\"The output focuses on architectural concepts and practices at the system and module-integration level and explicitly avoids shifting into implementation details, ensuring the discussion stays about structures, responsibilities, and interactions rather than how to write code.\\nThe output does not contain any programming language source code or command-line scripts (for example functions, classes, methods, shell commands, or configuration files) and does not include step-by-step coding instructions, which together constitute a coding solution.\\nWhen introducing or framing a topic, the output includes foundational explanations of project architecture principles, explicitly covering inter-module communication (defined as how separate components exchange data or invoke behavior through interfaces or protocols) and standardization in modular coding (defined as agreed conventions such as interface contracts, versioning schemes, configuration formats, logging, and error handling patterns).\\nThe output describes how individual modules (defined as self-contained components with clear responsibilities and a defined interface) integrate and communicate within a larger system and illustrates this integration with at least one concrete example or case.\\nWhen selection among architectural approaches is relevant to the user’s goal, the output names at least two architectural styles (for example layered architecture, microservices, event-driven, hexagonal, or serverless) and discusses the suitability of each style for different project contexts by citing typical strengths, trade-offs, and fit criteria.\\nWhen discussing architectural styles, the output provides at least one clearly identifiable resource for further learning (such as a book title, a standards document, a reputable article, or an official website) including enough detail to locate it (for example a title and author or a URL).\\nWhen analyzing a software project, the output explicitly identifies layers such as Frontend Application (defined as the user-facing client), Backend Service (defined as the server-side business logic and APIs), and Data Storage (defined as databases or other persistent stores) and explains for each layer its primary responsibilities and how it interacts with the other layers.\\nThe output includes practical exercises or actionable tasks that the user can perform (such as drawing a module diagram, mapping request flows end-to-end, defining interface contracts, or documenting non-functional requirements) to apply the discussed concepts in a realistic scenario.\\nTo emphasize practical application, the output references at least one real-world example, case study, or common industry scenario that concretely demonstrates the architectural concept or pattern being discussed.\\nWhen explaining project structure or layer interactions, the output includes at least one diagrammatic representation to aid understanding, such as an architecture diagram or a clearly labeled textual diagram (for example ASCII boxes and arrows) that shows components or modules and their interactions.\\nAny diagram included in the output clearly labels each component, shows relationships or communication flows using arrows or connectors with directionality where applicable, and visually or textually separates layers (such as frontend, backend, and data storage) when layered structure is being described.\\nThe output avoids overly technical language by not using unexplained jargon and by defining technical terms and expanding acronyms in plain language at their first appearance (for example defining SLA as service level agreement).\\nThe output maintains a professional and approachable tone by using clear complete sentences, encouraging and respectful phrasing, and by avoiding slang, sarcasm, excessive exclamation points, profanity, or emoticons.\\nWhen introducing technical concepts, the output includes at least one everyday analogy that maps the concept to familiar real-world objects or processes (for example comparing an API gateway to a receptionist routing requests), to make the explanation more accessible.\\nThe output is detailed yet concise by conveying sufficient information to understand the architectural topic while avoiding redundant repetition and unnecessary filler sentences, resulting in clear and compact paragraphs or bullet points.\\nIf the user’s project details are vague or missing—such as scale and traffic levels, non-functional requirements (for example performance, reliability, security, or compliance), deployment model (for example cloud versus on-premises), domain constraints, or intended architectural style—the output includes explicit clarification questions targeting the missing information before delivering prescriptive recommendations.\\nThe output may reference examining project README files and source code organization as evidence or as suggested study material to support educational insight, but it does not reproduce code or rely on code-level solutions.\\nThe output frames guidance with an educational intent by briefly stating the rationale behind recommendations (the why) and what the user will be able to understand or accomplish after applying the advice (the learning outcome).\\nWhen addressing modular integration and consistency, the output discusses standardization practices including but not limited to interface contracts, API versioning strategies, configuration conventions, logging approaches, and error handling policies to ensure modules interact predictably.\\nThe output keeps the perspective at the system level by discussing boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns across modules and layers rather than delving into internal algorithms, low-level data structures, or framework-specific code patterns.\",\"inputSpec\":\"The input is a natural-language prompt or description centered on software project architecture, modular design, and inter-module communication.\\nThe input can be a string containing project artifacts such as README text, source code snippets, configuration files, or textual architecture diagrams for architectural review.\\nThe input may describe multi-layered systems including frontend, backend, and data storage layers and how they interact.\\nThe input may include module-level details like APIs, events, messaging protocols, dependencies, and standardization practices.\\nThe input may ask to explore, compare, or select architectural styles suited to a particular project context.\\nThe input may request integration insights using examples or case studies provided within the input text.\\nThe input may request practical exercises or propose scenarios to practice architectural concepts.\\nThe input may include real-world constraints, non-functional requirements, goals, or project contexts to frame architectural considerations.\\nThe input may include textual representations of diagrams (Mermaid, PlantUML, ASCII) or descriptions of images that depict architecture.\\nThe input may reference or link to diagrams or images, which are considered textual descriptions for input purposes.\\nThe input may ask for educational review of repository structure, README content, or code files to understand project architecture.\\nThe input may provide code or configuration excerpts intended for analysis of module integration rather than implementation details.\\nThe input may consist of greetings, brief prompts, or vague descriptions that are valid and may require clarification.\\nThe input may include requests for analogies or everyday explanations of architectural concepts.\\nThe input may ask for resources or learning pathways related to project architecture and architectural styles.\\nThe input can be plain text with any formatting, including lists, code blocks, or markup, without specific formatting requirements.\\nThe input length is unrestricted and can range from a single sentence to a long, multi-section project description or multiple concatenated file contents.\\nThe input may include requests for coding solutions or code generation, and such requests are treated as valid inputs.\",\"intent\":\"Guide programmers to understand and manage complete software project architectures through clear, practical, non-coding guidance on inter-module integration, architectural styles, and real-world analyses and exercises.\"}"
    },
    "output": []
  },
  {
    "input": {
      "parameters": "{\"user_input\":\"audience: junior engineers; topic: introduce modular project architecture basics; request: explain foundational principles, inter-module communication patterns, and standardization practices like API versioning and schema governance; goal: start from fundamentals with simple language and analogies.\",\"rules\":\"The output focuses on architectural concepts and practices at the system and module-integration level and explicitly avoids shifting into implementation details, ensuring the discussion stays about structures, responsibilities, and interactions rather than how to write code.\\nThe output does not contain any programming language source code or command-line scripts (for example functions, classes, methods, shell commands, or configuration files) and does not include step-by-step coding instructions, which together constitute a coding solution.\\nWhen introducing or framing a topic, the output includes foundational explanations of project architecture principles, explicitly covering inter-module communication (defined as how separate components exchange data or invoke behavior through interfaces or protocols) and standardization in modular coding (defined as agreed conventions such as interface contracts, versioning schemes, configuration formats, logging, and error handling patterns).\\nThe output describes how individual modules (defined as self-contained components with clear responsibilities and a defined interface) integrate and communicate within a larger system and illustrates this integration with at least one concrete example or case.\\nWhen selection among architectural approaches is relevant to the user’s goal, the output names at least two architectural styles (for example layered architecture, microservices, event-driven, hexagonal, or serverless) and discusses the suitability of each style for different project contexts by citing typical strengths, trade-offs, and fit criteria.\\nWhen discussing architectural styles, the output provides at least one clearly identifiable resource for further learning (such as a book title, a standards document, a reputable article, or an official website) including enough detail to locate it (for example a title and author or a URL).\\nWhen analyzing a software project, the output explicitly identifies layers such as Frontend Application (defined as the user-facing client), Backend Service (defined as the server-side business logic and APIs), and Data Storage (defined as databases or other persistent stores) and explains for each layer its primary responsibilities and how it interacts with the other layers.\\nThe output includes practical exercises or actionable tasks that the user can perform (such as drawing a module diagram, mapping request flows end-to-end, defining interface contracts, or documenting non-functional requirements) to apply the discussed concepts in a realistic scenario.\\nTo emphasize practical application, the output references at least one real-world example, case study, or common industry scenario that concretely demonstrates the architectural concept or pattern being discussed.\\nWhen explaining project structure or layer interactions, the output includes at least one diagrammatic representation to aid understanding, such as an architecture diagram or a clearly labeled textual diagram (for example ASCII boxes and arrows) that shows components or modules and their interactions.\\nAny diagram included in the output clearly labels each component, shows relationships or communication flows using arrows or connectors with directionality where applicable, and visually or textually separates layers (such as frontend, backend, and data storage) when layered structure is being described.\\nThe output avoids overly technical language by not using unexplained jargon and by defining technical terms and expanding acronyms in plain language at their first appearance (for example defining SLA as service level agreement).\\nThe output maintains a professional and approachable tone by using clear complete sentences, encouraging and respectful phrasing, and by avoiding slang, sarcasm, excessive exclamation points, profanity, or emoticons.\\nWhen introducing technical concepts, the output includes at least one everyday analogy that maps the concept to familiar real-world objects or processes (for example comparing an API gateway to a receptionist routing requests), to make the explanation more accessible.\\nThe output is detailed yet concise by conveying sufficient information to understand the architectural topic while avoiding redundant repetition and unnecessary filler sentences, resulting in clear and compact paragraphs or bullet points.\\nIf the user’s project details are vague or missing—such as scale and traffic levels, non-functional requirements (for example performance, reliability, security, or compliance), deployment model (for example cloud versus on-premises), domain constraints, or intended architectural style—the output includes explicit clarification questions targeting the missing information before delivering prescriptive recommendations.\\nThe output may reference examining project README files and source code organization as evidence or as suggested study material to support educational insight, but it does not reproduce code or rely on code-level solutions.\\nThe output frames guidance with an educational intent by briefly stating the rationale behind recommendations (the why) and what the user will be able to understand or accomplish after applying the advice (the learning outcome).\\nWhen addressing modular integration and consistency, the output discusses standardization practices including but not limited to interface contracts, API versioning strategies, configuration conventions, logging approaches, and error handling policies to ensure modules interact predictably.\\nThe output keeps the perspective at the system level by discussing boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns across modules and layers rather than delving into internal algorithms, low-level data structures, or framework-specific code patterns.\",\"inputSpec\":\"The input is a natural-language prompt or description centered on software project architecture, modular design, and inter-module communication.\\nThe input can be a string containing project artifacts such as README text, source code snippets, configuration files, or textual architecture diagrams for architectural review.\\nThe input may describe multi-layered systems including frontend, backend, and data storage layers and how they interact.\\nThe input may include module-level details like APIs, events, messaging protocols, dependencies, and standardization practices.\\nThe input may ask to explore, compare, or select architectural styles suited to a particular project context.\\nThe input may request integration insights using examples or case studies provided within the input text.\\nThe input may request practical exercises or propose scenarios to practice architectural concepts.\\nThe input may include real-world constraints, non-functional requirements, goals, or project contexts to frame architectural considerations.\\nThe input may include textual representations of diagrams (Mermaid, PlantUML, ASCII) or descriptions of images that depict architecture.\\nThe input may reference or link to diagrams or images, which are considered textual descriptions for input purposes.\\nThe input may ask for educational review of repository structure, README content, or code files to understand project architecture.\\nThe input may provide code or configuration excerpts intended for analysis of module integration rather than implementation details.\\nThe input may consist of greetings, brief prompts, or vague descriptions that are valid and may require clarification.\\nThe input may include requests for analogies or everyday explanations of architectural concepts.\\nThe input may ask for resources or learning pathways related to project architecture and architectural styles.\\nThe input can be plain text with any formatting, including lists, code blocks, or markup, without specific formatting requirements.\\nThe input length is unrestricted and can range from a single sentence to a long, multi-section project description or multiple concatenated file contents.\\nThe input may include requests for coding solutions or code generation, and such requests are treated as valid inputs.\",\"intent\":\"Guide programmers to understand and manage complete software project architectures through clear, practical, non-coding guidance on inter-module integration, architectural styles, and real-world analyses and exercises.\"}"
    },
    "output": []
  },
  {
    "input": {
      "parameters": "{\"user_input\":\"Workshop Brief: Our team is new to system architecture. Goal: Learn foundational principles, especially inter-module communication and standardization practices to scale multiple teams. Context: Building a B2B SaaS with Web UI, API, and background workers. Request: Introduce the basics of project architecture, explicitly define inter-module communication and standardization in modular coding (interfaces, versioning, configs, logging, error handling), and frame the topic clearly.\",\"rules\":\"The output focuses on architectural concepts and practices at the system and module-integration level and explicitly avoids shifting into implementation details, ensuring the discussion stays about structures, responsibilities, and interactions rather than how to write code.\\nThe output does not contain any programming language source code or command-line scripts (for example functions, classes, methods, shell commands, or configuration files) and does not include step-by-step coding instructions, which together constitute a coding solution.\\nWhen introducing or framing a topic, the output includes foundational explanations of project architecture principles, explicitly covering inter-module communication (defined as how separate components exchange data or invoke behavior through interfaces or protocols) and standardization in modular coding (defined as agreed conventions such as interface contracts, versioning schemes, configuration formats, logging, and error handling patterns).\\nThe output describes how individual modules (defined as self-contained components with clear responsibilities and a defined interface) integrate and communicate within a larger system and illustrates this integration with at least one concrete example or case.\\nWhen selection among architectural approaches is relevant to the user’s goal, the output names at least two architectural styles (for example layered architecture, microservices, event-driven, hexagonal, or serverless) and discusses the suitability of each style for different project contexts by citing typical strengths, trade-offs, and fit criteria.\\nWhen discussing architectural styles, the output provides at least one clearly identifiable resource for further learning (such as a book title, a standards document, a reputable article, or an official website) including enough detail to locate it (for example a title and author or a URL).\\nWhen analyzing a software project, the output explicitly identifies layers such as Frontend Application (defined as the user-facing client), Backend Service (defined as the server-side business logic and APIs), and Data Storage (defined as databases or other persistent stores) and explains for each layer its primary responsibilities and how it interacts with the other layers.\\nThe output includes practical exercises or actionable tasks that the user can perform (such as drawing a module diagram, mapping request flows end-to-end, defining interface contracts, or documenting non-functional requirements) to apply the discussed concepts in a realistic scenario.\\nTo emphasize practical application, the output references at least one real-world example, case study, or common industry scenario that concretely demonstrates the architectural concept or pattern being discussed.\\nWhen explaining project structure or layer interactions, the output includes at least one diagrammatic representation to aid understanding, such as an architecture diagram or a clearly labeled textual diagram (for example ASCII boxes and arrows) that shows components or modules and their interactions.\\nAny diagram included in the output clearly labels each component, shows relationships or communication flows using arrows or connectors with directionality where applicable, and visually or textually separates layers (such as frontend, backend, and data storage) when layered structure is being described.\\nThe output avoids overly technical language by not using unexplained jargon and by defining technical terms and expanding acronyms in plain language at their first appearance (for example defining SLA as service level agreement).\\nThe output maintains a professional and approachable tone by using clear complete sentences, encouraging and respectful phrasing, and by avoiding slang, sarcasm, excessive exclamation points, profanity, or emoticons.\\nWhen introducing technical concepts, the output includes at least one everyday analogy that maps the concept to familiar real-world objects or processes (for example comparing an API gateway to a receptionist routing requests), to make the explanation more accessible.\\nThe output is detailed yet concise by conveying sufficient information to understand the architectural topic while avoiding redundant repetition and unnecessary filler sentences, resulting in clear and compact paragraphs or bullet points.\\nIf the user’s project details are vague or missing—such as scale and traffic levels, non-functional requirements (for example performance, reliability, security, or compliance), deployment model (for example cloud versus on-premises), domain constraints, or intended architectural style—the output includes explicit clarification questions targeting the missing information before delivering prescriptive recommendations.\\nThe output may reference examining project README files and source code organization as evidence or as suggested study material to support educational insight, but it does not reproduce code or rely on code-level solutions.\\nThe output frames guidance with an educational intent by briefly stating the rationale behind recommendations (the why) and what the user will be able to understand or accomplish after applying the advice (the learning outcome).\\nWhen addressing modular integration and consistency, the output discusses standardization practices including but not limited to interface contracts, API versioning strategies, configuration conventions, logging approaches, and error handling policies to ensure modules interact predictably.\\nThe output keeps the perspective at the system level by discussing boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns across modules and layers rather than delving into internal algorithms, low-level data structures, or framework-specific code patterns.\",\"inputSpec\":\"The input is a natural-language prompt or description centered on software project architecture, modular design, and inter-module communication.\\nThe input can be a string containing project artifacts such as README text, source code snippets, configuration files, or textual architecture diagrams for architectural review.\\nThe input may describe multi-layered systems including frontend, backend, and data storage layers and how they interact.\\nThe input may include module-level details like APIs, events, messaging protocols, dependencies, and standardization practices.\\nThe input may ask to explore, compare, or select architectural styles suited to a particular project context.\\nThe input may request integration insights using examples or case studies provided within the input text.\\nThe input may request practical exercises or propose scenarios to practice architectural concepts.\\nThe input may include real-world constraints, non-functional requirements, goals, or project contexts to frame architectural considerations.\\nThe input may include textual representations of diagrams (Mermaid, PlantUML, ASCII) or descriptions of images that depict architecture.\\nThe input may reference or link to diagrams or images, which are considered textual descriptions for input purposes.\\nThe input may ask for educational review of repository structure, README content, or code files to understand project architecture.\\nThe input may provide code or configuration excerpts intended for analysis of module integration rather than implementation details.\\nThe input may consist of greetings, brief prompts, or vague descriptions that are valid and may require clarification.\\nThe input may include requests for analogies or everyday explanations of architectural concepts.\\nThe input may ask for resources or learning pathways related to project architecture and architectural styles.\\nThe input can be plain text with any formatting, including lists, code blocks, or markup, without specific formatting requirements.\\nThe input length is unrestricted and can range from a single sentence to a long, multi-section project description or multiple concatenated file contents.\\nThe input may include requests for coding solutions or code generation, and such requests are treated as valid inputs.\",\"intent\":\"Guide programmers to understand and manage complete software project architectures through clear, practical, non-coding guidance on inter-module integration, architectural styles, and real-world analyses and exercises.\"}"
    },
    "output": []
  },
  {
    "input": {
      "parameters": "{\"user_input\":\"Case Study Request: E-commerce order pipeline. Modules: Auth, Product Catalog, Cart, Order, Payment, Inventory, Notification. Protocols: Web to API via HTTPS; services publish and subscribe to events like OrderPlaced and PaymentAuthorized. Request: Describe how these modules integrate and communicate within the system and include at least one concrete example flow end-to-end.\",\"rules\":\"The output focuses on architectural concepts and practices at the system and module-integration level and explicitly avoids shifting into implementation details, ensuring the discussion stays about structures, responsibilities, and interactions rather than how to write code.\\nThe output does not contain any programming language source code or command-line scripts (for example functions, classes, methods, shell commands, or configuration files) and does not include step-by-step coding instructions, which together constitute a coding solution.\\nWhen introducing or framing a topic, the output includes foundational explanations of project architecture principles, explicitly covering inter-module communication (defined as how separate components exchange data or invoke behavior through interfaces or protocols) and standardization in modular coding (defined as agreed conventions such as interface contracts, versioning schemes, configuration formats, logging, and error handling patterns).\\nThe output describes how individual modules (defined as self-contained components with clear responsibilities and a defined interface) integrate and communicate within a larger system and illustrates this integration with at least one concrete example or case.\\nWhen selection among architectural approaches is relevant to the user’s goal, the output names at least two architectural styles (for example layered architecture, microservices, event-driven, hexagonal, or serverless) and discusses the suitability of each style for different project contexts by citing typical strengths, trade-offs, and fit criteria.\\nWhen discussing architectural styles, the output provides at least one clearly identifiable resource for further learning (such as a book title, a standards document, a reputable article, or an official website) including enough detail to locate it (for example a title and author or a URL).\\nWhen analyzing a software project, the output explicitly identifies layers such as Frontend Application (defined as the user-facing client), Backend Service (defined as the server-side business logic and APIs), and Data Storage (defined as databases or other persistent stores) and explains for each layer its primary responsibilities and how it interacts with the other layers.\\nThe output includes practical exercises or actionable tasks that the user can perform (such as drawing a module diagram, mapping request flows end-to-end, defining interface contracts, or documenting non-functional requirements) to apply the discussed concepts in a realistic scenario.\\nTo emphasize practical application, the output references at least one real-world example, case study, or common industry scenario that concretely demonstrates the architectural concept or pattern being discussed.\\nWhen explaining project structure or layer interactions, the output includes at least one diagrammatic representation to aid understanding, such as an architecture diagram or a clearly labeled textual diagram (for example ASCII boxes and arrows) that shows components or modules and their interactions.\\nAny diagram included in the output clearly labels each component, shows relationships or communication flows using arrows or connectors with directionality where applicable, and visually or textually separates layers (such as frontend, backend, and data storage) when layered structure is being described.\\nThe output avoids overly technical language by not using unexplained jargon and by defining technical terms and expanding acronyms in plain language at their first appearance (for example defining SLA as service level agreement).\\nThe output maintains a professional and approachable tone by using clear complete sentences, encouraging and respectful phrasing, and by avoiding slang, sarcasm, excessive exclamation points, profanity, or emoticons.\\nWhen introducing technical concepts, the output includes at least one everyday analogy that maps the concept to familiar real-world objects or processes (for example comparing an API gateway to a receptionist routing requests), to make the explanation more accessible.\\nThe output is detailed yet concise by conveying sufficient information to understand the architectural topic while avoiding redundant repetition and unnecessary filler sentences, resulting in clear and compact paragraphs or bullet points.\\nIf the user’s project details are vague or missing—such as scale and traffic levels, non-functional requirements (for example performance, reliability, security, or compliance), deployment model (for example cloud versus on-premises), domain constraints, or intended architectural style—the output includes explicit clarification questions targeting the missing information before delivering prescriptive recommendations.\\nThe output may reference examining project README files and source code organization as evidence or as suggested study material to support educational insight, but it does not reproduce code or rely on code-level solutions.\\nThe output frames guidance with an educational intent by briefly stating the rationale behind recommendations (the why) and what the user will be able to understand or accomplish after applying the advice (the learning outcome).\\nWhen addressing modular integration and consistency, the output discusses standardization practices including but not limited to interface contracts, API versioning strategies, configuration conventions, logging approaches, and error handling policies to ensure modules interact predictably.\\nThe output keeps the perspective at the system level by discussing boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns across modules and layers rather than delving into internal algorithms, low-level data structures, or framework-specific code patterns.\",\"inputSpec\":\"The input is a natural-language prompt or description centered on software project architecture, modular design, and inter-module communication.\\nThe input can be a string containing project artifacts such as README text, source code snippets, configuration files, or textual architecture diagrams for architectural review.\\nThe input may describe multi-layered systems including frontend, backend, and data storage layers and how they interact.\\nThe input may include module-level details like APIs, events, messaging protocols, dependencies, and standardization practices.\\nThe input may ask to explore, compare, or select architectural styles suited to a particular project context.\\nThe input may request integration insights using examples or case studies provided within the input text.\\nThe input may request practical exercises or propose scenarios to practice architectural concepts.\\nThe input may include real-world constraints, non-functional requirements, goals, or project contexts to frame architectural considerations.\\nThe input may include textual representations of diagrams (Mermaid, PlantUML, ASCII) or descriptions of images that depict architecture.\\nThe input may reference or link to diagrams or images, which are considered textual descriptions for input purposes.\\nThe input may ask for educational review of repository structure, README content, or code files to understand project architecture.\\nThe input may provide code or configuration excerpts intended for analysis of module integration rather than implementation details.\\nThe input may consist of greetings, brief prompts, or vague descriptions that are valid and may require clarification.\\nThe input may include requests for analogies or everyday explanations of architectural concepts.\\nThe input may ask for resources or learning pathways related to project architecture and architectural styles.\\nThe input can be plain text with any formatting, including lists, code blocks, or markup, without specific formatting requirements.\\nThe input length is unrestricted and can range from a single sentence to a long, multi-section project description or multiple concatenated file contents.\\nThe input may include requests for coding solutions or code generation, and such requests are treated as valid inputs.\",\"intent\":\"Guide programmers to understand and manage complete software project architectures through clear, practical, non-coding guidance on inter-module integration, architectural styles, and real-world analyses and exercises.\"}"
    },
    "output": []
  },
  {
    "input": {
      "parameters": "{\"user_input\":\"Project Analysis: Analytics SaaS. Frontend Application: Single-page app for dashboards and data exploration. Backend Service: REST or GraphQL APIs for queries, ingestion workers, auth and rate limiting. Data Storage: PostgreSQL for transactional metadata, ClickHouse for analytics queries, S3 for raw files. Request: Identify each layer’s primary responsibilities and explain how Frontend, Backend, and Data Storage interact.\",\"rules\":\"The output focuses on architectural concepts and practices at the system and module-integration level and explicitly avoids shifting into implementation details, ensuring the discussion stays about structures, responsibilities, and interactions rather than how to write code.\\nThe output does not contain any programming language source code or command-line scripts (for example functions, classes, methods, shell commands, or configuration files) and does not include step-by-step coding instructions, which together constitute a coding solution.\\nWhen introducing or framing a topic, the output includes foundational explanations of project architecture principles, explicitly covering inter-module communication (defined as how separate components exchange data or invoke behavior through interfaces or protocols) and standardization in modular coding (defined as agreed conventions such as interface contracts, versioning schemes, configuration formats, logging, and error handling patterns).\\nThe output describes how individual modules (defined as self-contained components with clear responsibilities and a defined interface) integrate and communicate within a larger system and illustrates this integration with at least one concrete example or case.\\nWhen selection among architectural approaches is relevant to the user’s goal, the output names at least two architectural styles (for example layered architecture, microservices, event-driven, hexagonal, or serverless) and discusses the suitability of each style for different project contexts by citing typical strengths, trade-offs, and fit criteria.\\nWhen discussing architectural styles, the output provides at least one clearly identifiable resource for further learning (such as a book title, a standards document, a reputable article, or an official website) including enough detail to locate it (for example a title and author or a URL).\\nWhen analyzing a software project, the output explicitly identifies layers such as Frontend Application (defined as the user-facing client), Backend Service (defined as the server-side business logic and APIs), and Data Storage (defined as databases or other persistent stores) and explains for each layer its primary responsibilities and how it interacts with the other layers.\\nThe output includes practical exercises or actionable tasks that the user can perform (such as drawing a module diagram, mapping request flows end-to-end, defining interface contracts, or documenting non-functional requirements) to apply the discussed concepts in a realistic scenario.\\nTo emphasize practical application, the output references at least one real-world example, case study, or common industry scenario that concretely demonstrates the architectural concept or pattern being discussed.\\nWhen explaining project structure or layer interactions, the output includes at least one diagrammatic representation to aid understanding, such as an architecture diagram or a clearly labeled textual diagram (for example ASCII boxes and arrows) that shows components or modules and their interactions.\\nAny diagram included in the output clearly labels each component, shows relationships or communication flows using arrows or connectors with directionality where applicable, and visually or textually separates layers (such as frontend, backend, and data storage) when layered structure is being described.\\nThe output avoids overly technical language by not using unexplained jargon and by defining technical terms and expanding acronyms in plain language at their first appearance (for example defining SLA as service level agreement).\\nThe output maintains a professional and approachable tone by using clear complete sentences, encouraging and respectful phrasing, and by avoiding slang, sarcasm, excessive exclamation points, profanity, or emoticons.\\nWhen introducing technical concepts, the output includes at least one everyday analogy that maps the concept to familiar real-world objects or processes (for example comparing an API gateway to a receptionist routing requests), to make the explanation more accessible.\\nThe output is detailed yet concise by conveying sufficient information to understand the architectural topic while avoiding redundant repetition and unnecessary filler sentences, resulting in clear and compact paragraphs or bullet points.\\nIf the user’s project details are vague or missing—such as scale and traffic levels, non-functional requirements (for example performance, reliability, security, or compliance), deployment model (for example cloud versus on-premises), domain constraints, or intended architectural style—the output includes explicit clarification questions targeting the missing information before delivering prescriptive recommendations.\\nThe output may reference examining project README files and source code organization as evidence or as suggested study material to support educational insight, but it does not reproduce code or rely on code-level solutions.\\nThe output frames guidance with an educational intent by briefly stating the rationale behind recommendations (the why) and what the user will be able to understand or accomplish after applying the advice (the learning outcome).\\nWhen addressing modular integration and consistency, the output discusses standardization practices including but not limited to interface contracts, API versioning strategies, configuration conventions, logging approaches, and error handling policies to ensure modules interact predictably.\\nThe output keeps the perspective at the system level by discussing boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns across modules and layers rather than delving into internal algorithms, low-level data structures, or framework-specific code patterns.\",\"inputSpec\":\"The input is a natural-language prompt or description centered on software project architecture, modular design, and inter-module communication.\\nThe input can be a string containing project artifacts such as README text, source code snippets, configuration files, or textual architecture diagrams for architectural review.\\nThe input may describe multi-layered systems including frontend, backend, and data storage layers and how they interact.\\nThe input may include module-level details like APIs, events, messaging protocols, dependencies, and standardization practices.\\nThe input may ask to explore, compare, or select architectural styles suited to a particular project context.\\nThe input may request integration insights using examples or case studies provided within the input text.\\nThe input may request practical exercises or propose scenarios to practice architectural concepts.\\nThe input may include real-world constraints, non-functional requirements, goals, or project contexts to frame architectural considerations.\\nThe input may include textual representations of diagrams (Mermaid, PlantUML, ASCII) or descriptions of images that depict architecture.\\nThe input may reference or link to diagrams or images, which are considered textual descriptions for input purposes.\\nThe input may ask for educational review of repository structure, README content, or code files to understand project architecture.\\nThe input may provide code or configuration excerpts intended for analysis of module integration rather than implementation details.\\nThe input may consist of greetings, brief prompts, or vague descriptions that are valid and may require clarification.\\nThe input may include requests for analogies or everyday explanations of architectural concepts.\\nThe input may ask for resources or learning pathways related to project architecture and architectural styles.\\nThe input can be plain text with any formatting, including lists, code blocks, or markup, without specific formatting requirements.\\nThe input length is unrestricted and can range from a single sentence to a long, multi-section project description or multiple concatenated file contents.\\nThe input may include requests for coding solutions or code generation, and such requests are treated as valid inputs.\",\"intent\":\"Guide programmers to understand and manage complete software project architectures through clear, practical, non-coding guidance on inter-module integration, architectural styles, and real-world analyses and exercises.\"}"
    },
    "output": []
  },
  {
    "input": {
      "parameters": "{\"user_input\":\"Practical Exercises Request: IoT fleet management platform. Modules: Device Gateway, Command Service, Telemetry Processor, Alerting, Admin UI. Constraints: Intermittent connectivity; millions of devices; priority on safety and observability. Request: Provide actionable exercises to practice architecture integration (e.g., diagrams, request and telemetry flow mapping, interface contracts, NFR documentation, failure-mode drills).\",\"rules\":\"The output focuses on architectural concepts and practices at the system and module-integration level and explicitly avoids shifting into implementation details, ensuring the discussion stays about structures, responsibilities, and interactions rather than how to write code.\\nThe output does not contain any programming language source code or command-line scripts (for example functions, classes, methods, shell commands, or configuration files) and does not include step-by-step coding instructions, which together constitute a coding solution.\\nWhen introducing or framing a topic, the output includes foundational explanations of project architecture principles, explicitly covering inter-module communication (defined as how separate components exchange data or invoke behavior through interfaces or protocols) and standardization in modular coding (defined as agreed conventions such as interface contracts, versioning schemes, configuration formats, logging, and error handling patterns).\\nThe output describes how individual modules (defined as self-contained components with clear responsibilities and a defined interface) integrate and communicate within a larger system and illustrates this integration with at least one concrete example or case.\\nWhen selection among architectural approaches is relevant to the user’s goal, the output names at least two architectural styles (for example layered architecture, microservices, event-driven, hexagonal, or serverless) and discusses the suitability of each style for different project contexts by citing typical strengths, trade-offs, and fit criteria.\\nWhen discussing architectural styles, the output provides at least one clearly identifiable resource for further learning (such as a book title, a standards document, a reputable article, or an official website) including enough detail to locate it (for example a title and author or a URL).\\nWhen analyzing a software project, the output explicitly identifies layers such as Frontend Application (defined as the user-facing client), Backend Service (defined as the server-side business logic and APIs), and Data Storage (defined as databases or other persistent stores) and explains for each layer its primary responsibilities and how it interacts with the other layers.\\nThe output includes practical exercises or actionable tasks that the user can perform (such as drawing a module diagram, mapping request flows end-to-end, defining interface contracts, or documenting non-functional requirements) to apply the discussed concepts in a realistic scenario.\\nTo emphasize practical application, the output references at least one real-world example, case study, or common industry scenario that concretely demonstrates the architectural concept or pattern being discussed.\\nWhen explaining project structure or layer interactions, the output includes at least one diagrammatic representation to aid understanding, such as an architecture diagram or a clearly labeled textual diagram (for example ASCII boxes and arrows) that shows components or modules and their interactions.\\nAny diagram included in the output clearly labels each component, shows relationships or communication flows using arrows or connectors with directionality where applicable, and visually or textually separates layers (such as frontend, backend, and data storage) when layered structure is being described.\\nThe output avoids overly technical language by not using unexplained jargon and by defining technical terms and expanding acronyms in plain language at their first appearance (for example defining SLA as service level agreement).\\nThe output maintains a professional and approachable tone by using clear complete sentences, encouraging and respectful phrasing, and by avoiding slang, sarcasm, excessive exclamation points, profanity, or emoticons.\\nWhen introducing technical concepts, the output includes at least one everyday analogy that maps the concept to familiar real-world objects or processes (for example comparing an API gateway to a receptionist routing requests), to make the explanation more accessible.\\nThe output is detailed yet concise by conveying sufficient information to understand the architectural topic while avoiding redundant repetition and unnecessary filler sentences, resulting in clear and compact paragraphs or bullet points.\\nIf the user’s project details are vague or missing—such as scale and traffic levels, non-functional requirements (for example performance, reliability, security, or compliance), deployment model (for example cloud versus on-premises), domain constraints, or intended architectural style—the output includes explicit clarification questions targeting the missing information before delivering prescriptive recommendations.\\nThe output may reference examining project README files and source code organization as evidence or as suggested study material to support educational insight, but it does not reproduce code or rely on code-level solutions.\\nThe output frames guidance with an educational intent by briefly stating the rationale behind recommendations (the why) and what the user will be able to understand or accomplish after applying the advice (the learning outcome).\\nWhen addressing modular integration and consistency, the output discusses standardization practices including but not limited to interface contracts, API versioning strategies, configuration conventions, logging approaches, and error handling policies to ensure modules interact predictably.\\nThe output keeps the perspective at the system level by discussing boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns across modules and layers rather than delving into internal algorithms, low-level data structures, or framework-specific code patterns.\",\"inputSpec\":\"The input is a natural-language prompt or description centered on software project architecture, modular design, and inter-module communication.\\nThe input can be a string containing project artifacts such as README text, source code snippets, configuration files, or textual architecture diagrams for architectural review.\\nThe input may describe multi-layered systems including frontend, backend, and data storage layers and how they interact.\\nThe input may include module-level details like APIs, events, messaging protocols, dependencies, and standardization practices.\\nThe input may ask to explore, compare, or select architectural styles suited to a particular project context.\\nThe input may request integration insights using examples or case studies provided within the input text.\\nThe input may request practical exercises or propose scenarios to practice architectural concepts.\\nThe input may include real-world constraints, non-functional requirements, goals, or project contexts to frame architectural considerations.\\nThe input may include textual representations of diagrams (Mermaid, PlantUML, ASCII) or descriptions of images that depict architecture.\\nThe input may reference or link to diagrams or images, which are considered textual descriptions for input purposes.\\nThe input may ask for educational review of repository structure, README content, or code files to understand project architecture.\\nThe input may provide code or configuration excerpts intended for analysis of module integration rather than implementation details.\\nThe input may consist of greetings, brief prompts, or vague descriptions that are valid and may require clarification.\\nThe input may include requests for analogies or everyday explanations of architectural concepts.\\nThe input may ask for resources or learning pathways related to project architecture and architectural styles.\\nThe input can be plain text with any formatting, including lists, code blocks, or markup, without specific formatting requirements.\\nThe input length is unrestricted and can range from a single sentence to a long, multi-section project description or multiple concatenated file contents.\\nThe input may include requests for coding solutions or code generation, and such requests are treated as valid inputs.\",\"intent\":\"Guide programmers to understand and manage complete software project architectures through clear, practical, non-coding guidance on inter-module integration, architectural styles, and real-world analyses and exercises.\"}"
    },
    "output": []
  },
  {
    "input": {
      "parameters": "{\"user_input\":\"Applied Patterns: Please explain event-driven architecture in practice. Context: Logistics parcel tracking system across multiple carriers and hubs. Request: Include at least one real-world example or common industry scenario that concretely demonstrates the pattern and why it is effective.\",\"rules\":\"The output focuses on architectural concepts and practices at the system and module-integration level and explicitly avoids shifting into implementation details, ensuring the discussion stays about structures, responsibilities, and interactions rather than how to write code.\\nThe output does not contain any programming language source code or command-line scripts (for example functions, classes, methods, shell commands, or configuration files) and does not include step-by-step coding instructions, which together constitute a coding solution.\\nWhen introducing or framing a topic, the output includes foundational explanations of project architecture principles, explicitly covering inter-module communication (defined as how separate components exchange data or invoke behavior through interfaces or protocols) and standardization in modular coding (defined as agreed conventions such as interface contracts, versioning schemes, configuration formats, logging, and error handling patterns).\\nThe output describes how individual modules (defined as self-contained components with clear responsibilities and a defined interface) integrate and communicate within a larger system and illustrates this integration with at least one concrete example or case.\\nWhen selection among architectural approaches is relevant to the user’s goal, the output names at least two architectural styles (for example layered architecture, microservices, event-driven, hexagonal, or serverless) and discusses the suitability of each style for different project contexts by citing typical strengths, trade-offs, and fit criteria.\\nWhen discussing architectural styles, the output provides at least one clearly identifiable resource for further learning (such as a book title, a standards document, a reputable article, or an official website) including enough detail to locate it (for example a title and author or a URL).\\nWhen analyzing a software project, the output explicitly identifies layers such as Frontend Application (defined as the user-facing client), Backend Service (defined as the server-side business logic and APIs), and Data Storage (defined as databases or other persistent stores) and explains for each layer its primary responsibilities and how it interacts with the other layers.\\nThe output includes practical exercises or actionable tasks that the user can perform (such as drawing a module diagram, mapping request flows end-to-end, defining interface contracts, or documenting non-functional requirements) to apply the discussed concepts in a realistic scenario.\\nTo emphasize practical application, the output references at least one real-world example, case study, or common industry scenario that concretely demonstrates the architectural concept or pattern being discussed.\\nWhen explaining project structure or layer interactions, the output includes at least one diagrammatic representation to aid understanding, such as an architecture diagram or a clearly labeled textual diagram (for example ASCII boxes and arrows) that shows components or modules and their interactions.\\nAny diagram included in the output clearly labels each component, shows relationships or communication flows using arrows or connectors with directionality where applicable, and visually or textually separates layers (such as frontend, backend, and data storage) when layered structure is being described.\\nThe output avoids overly technical language by not using unexplained jargon and by defining technical terms and expanding acronyms in plain language at their first appearance (for example defining SLA as service level agreement).\\nThe output maintains a professional and approachable tone by using clear complete sentences, encouraging and respectful phrasing, and by avoiding slang, sarcasm, excessive exclamation points, profanity, or emoticons.\\nWhen introducing technical concepts, the output includes at least one everyday analogy that maps the concept to familiar real-world objects or processes (for example comparing an API gateway to a receptionist routing requests), to make the explanation more accessible.\\nThe output is detailed yet concise by conveying sufficient information to understand the architectural topic while avoiding redundant repetition and unnecessary filler sentences, resulting in clear and compact paragraphs or bullet points.\\nIf the user’s project details are vague or missing—such as scale and traffic levels, non-functional requirements (for example performance, reliability, security, or compliance), deployment model (for example cloud versus on-premises), domain constraints, or intended architectural style—the output includes explicit clarification questions targeting the missing information before delivering prescriptive recommendations.\\nThe output may reference examining project README files and source code organization as evidence or as suggested study material to support educational insight, but it does not reproduce code or rely on code-level solutions.\\nThe output frames guidance with an educational intent by briefly stating the rationale behind recommendations (the why) and what the user will be able to understand or accomplish after applying the advice (the learning outcome).\\nWhen addressing modular integration and consistency, the output discusses standardization practices including but not limited to interface contracts, API versioning strategies, configuration conventions, logging approaches, and error handling policies to ensure modules interact predictably.\\nThe output keeps the perspective at the system level by discussing boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns across modules and layers rather than delving into internal algorithms, low-level data structures, or framework-specific code patterns.\",\"inputSpec\":\"The input is a natural-language prompt or description centered on software project architecture, modular design, and inter-module communication.\\nThe input can be a string containing project artifacts such as README text, source code snippets, configuration files, or textual architecture diagrams for architectural review.\\nThe input may describe multi-layered systems including frontend, backend, and data storage layers and how they interact.\\nThe input may include module-level details like APIs, events, messaging protocols, dependencies, and standardization practices.\\nThe input may ask to explore, compare, or select architectural styles suited to a particular project context.\\nThe input may request integration insights using examples or case studies provided within the input text.\\nThe input may request practical exercises or propose scenarios to practice architectural concepts.\\nThe input may include real-world constraints, non-functional requirements, goals, or project contexts to frame architectural considerations.\\nThe input may include textual representations of diagrams (Mermaid, PlantUML, ASCII) or descriptions of images that depict architecture.\\nThe input may reference or link to diagrams or images, which are considered textual descriptions for input purposes.\\nThe input may ask for educational review of repository structure, README content, or code files to understand project architecture.\\nThe input may provide code or configuration excerpts intended for analysis of module integration rather than implementation details.\\nThe input may consist of greetings, brief prompts, or vague descriptions that are valid and may require clarification.\\nThe input may include requests for analogies or everyday explanations of architectural concepts.\\nThe input may ask for resources or learning pathways related to project architecture and architectural styles.\\nThe input can be plain text with any formatting, including lists, code blocks, or markup, without specific formatting requirements.\\nThe input length is unrestricted and can range from a single sentence to a long, multi-section project description or multiple concatenated file contents.\\nThe input may include requests for coding solutions or code generation, and such requests are treated as valid inputs.\",\"intent\":\"Guide programmers to understand and manage complete software project architectures through clear, practical, non-coding guidance on inter-module integration, architectural styles, and real-world analyses and exercises.\"}"
    },
    "output": []
  },
  {
    "input": {
      "parameters": "{\"user_input\":\"Architecture Decision: Fintech MVP for peer-to-peer payments. Team: 6 engineers; low ops maturity; Compliance: audits, PII protection. Workload: Mobile clients; bursty traffic; need feature velocity. Request: Compare at least two architectural styles and discuss suitability with strengths, trade-offs, and fit criteria for this context.\",\"rules\":\"The output focuses on architectural concepts and practices at the system and module-integration level and explicitly avoids shifting into implementation details, ensuring the discussion stays about structures, responsibilities, and interactions rather than how to write code.\\nThe output does not contain any programming language source code or command-line scripts (for example functions, classes, methods, shell commands, or configuration files) and does not include step-by-step coding instructions, which together constitute a coding solution.\\nWhen introducing or framing a topic, the output includes foundational explanations of project architecture principles, explicitly covering inter-module communication (defined as how separate components exchange data or invoke behavior through interfaces or protocols) and standardization in modular coding (defined as agreed conventions such as interface contracts, versioning schemes, configuration formats, logging, and error handling patterns).\\nThe output describes how individual modules (defined as self-contained components with clear responsibilities and a defined interface) integrate and communicate within a larger system and illustrates this integration with at least one concrete example or case.\\nWhen selection among architectural approaches is relevant to the user’s goal, the output names at least two architectural styles (for example layered architecture, microservices, event-driven, hexagonal, or serverless) and discusses the suitability of each style for different project contexts by citing typical strengths, trade-offs, and fit criteria.\\nWhen discussing architectural styles, the output provides at least one clearly identifiable resource for further learning (such as a book title, a standards document, a reputable article, or an official website) including enough detail to locate it (for example a title and author or a URL).\\nWhen analyzing a software project, the output explicitly identifies layers such as Frontend Application (defined as the user-facing client), Backend Service (defined as the server-side business logic and APIs), and Data Storage (defined as databases or other persistent stores) and explains for each layer its primary responsibilities and how it interacts with the other layers.\\nThe output includes practical exercises or actionable tasks that the user can perform (such as drawing a module diagram, mapping request flows end-to-end, defining interface contracts, or documenting non-functional requirements) to apply the discussed concepts in a realistic scenario.\\nTo emphasize practical application, the output references at least one real-world example, case study, or common industry scenario that concretely demonstrates the architectural concept or pattern being discussed.\\nWhen explaining project structure or layer interactions, the output includes at least one diagrammatic representation to aid understanding, such as an architecture diagram or a clearly labeled textual diagram (for example ASCII boxes and arrows) that shows components or modules and their interactions.\\nAny diagram included in the output clearly labels each component, shows relationships or communication flows using arrows or connectors with directionality where applicable, and visually or textually separates layers (such as frontend, backend, and data storage) when layered structure is being described.\\nThe output avoids overly technical language by not using unexplained jargon and by defining technical terms and expanding acronyms in plain language at their first appearance (for example defining SLA as service level agreement).\\nThe output maintains a professional and approachable tone by using clear complete sentences, encouraging and respectful phrasing, and by avoiding slang, sarcasm, excessive exclamation points, profanity, or emoticons.\\nWhen introducing technical concepts, the output includes at least one everyday analogy that maps the concept to familiar real-world objects or processes (for example comparing an API gateway to a receptionist routing requests), to make the explanation more accessible.\\nThe output is detailed yet concise by conveying sufficient information to understand the architectural topic while avoiding redundant repetition and unnecessary filler sentences, resulting in clear and compact paragraphs or bullet points.\\nIf the user’s project details are vague or missing—such as scale and traffic levels, non-functional requirements (for example performance, reliability, security, or compliance), deployment model (for example cloud versus on-premises), domain constraints, or intended architectural style—the output includes explicit clarification questions targeting the missing information before delivering prescriptive recommendations.\\nThe output may reference examining project README files and source code organization as evidence or as suggested study material to support educational insight, but it does not reproduce code or rely on code-level solutions.\\nThe output frames guidance with an educational intent by briefly stating the rationale behind recommendations (the why) and what the user will be able to understand or accomplish after applying the advice (the learning outcome).\\nWhen addressing modular integration and consistency, the output discusses standardization practices including but not limited to interface contracts, API versioning strategies, configuration conventions, logging approaches, and error handling policies to ensure modules interact predictably.\\nThe output keeps the perspective at the system level by discussing boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns across modules and layers rather than delving into internal algorithms, low-level data structures, or framework-specific code patterns.\",\"inputSpec\":\"The input is a natural-language prompt or description centered on software project architecture, modular design, and inter-module communication.\\nThe input can be a string containing project artifacts such as README text, source code snippets, configuration files, or textual architecture diagrams for architectural review.\\nThe input may describe multi-layered systems including frontend, backend, and data storage layers and how they interact.\\nThe input may include module-level details like APIs, events, messaging protocols, dependencies, and standardization practices.\\nThe input may ask to explore, compare, or select architectural styles suited to a particular project context.\\nThe input may request integration insights using examples or case studies provided within the input text.\\nThe input may request practical exercises or propose scenarios to practice architectural concepts.\\nThe input may include real-world constraints, non-functional requirements, goals, or project contexts to frame architectural considerations.\\nThe input may include textual representations of diagrams (Mermaid, PlantUML, ASCII) or descriptions of images that depict architecture.\\nThe input may reference or link to diagrams or images, which are considered textual descriptions for input purposes.\\nThe input may ask for educational review of repository structure, README content, or code files to understand project architecture.\\nThe input may provide code or configuration excerpts intended for analysis of module integration rather than implementation details.\\nThe input may consist of greetings, brief prompts, or vague descriptions that are valid and may require clarification.\\nThe input may include requests for analogies or everyday explanations of architectural concepts.\\nThe input may ask for resources or learning pathways related to project architecture and architectural styles.\\nThe input can be plain text with any formatting, including lists, code blocks, or markup, without specific formatting requirements.\\nThe input length is unrestricted and can range from a single sentence to a long, multi-section project description or multiple concatenated file contents.\\nThe input may include requests for coding solutions or code generation, and such requests are treated as valid inputs.\",\"intent\":\"Guide programmers to understand and manage complete software project architectures through clear, practical, non-coding guidance on inter-module integration, architectural styles, and real-world analyses and exercises.\"}"
    },
    "output": []
  },
  {
    "input": {
      "parameters": "{\"user_input\":\"project_context: Single-page app with React frontend, Node.js backend, Postgres DB; request: show a concrete end-to-end example of how modules integrate and communicate including HTTP paths, headers, an event emission, and a SQL query; ask: include at least one concrete case.\",\"rules\":\"The output focuses on architectural concepts and practices at the system and module-integration level and explicitly avoids shifting into implementation details, ensuring the discussion stays about structures, responsibilities, and interactions rather than how to write code.\\nThe output does not contain any programming language source code or command-line scripts (for example functions, classes, methods, shell commands, or configuration files) and does not include step-by-step coding instructions, which together constitute a coding solution.\\nWhen introducing or framing a topic, the output includes foundational explanations of project architecture principles, explicitly covering inter-module communication (defined as how separate components exchange data or invoke behavior through interfaces or protocols) and standardization in modular coding (defined as agreed conventions such as interface contracts, versioning schemes, configuration formats, logging, and error handling patterns).\\nThe output describes how individual modules (defined as self-contained components with clear responsibilities and a defined interface) integrate and communicate within a larger system and illustrates this integration with at least one concrete example or case.\\nWhen selection among architectural approaches is relevant to the user’s goal, the output names at least two architectural styles (for example layered architecture, microservices, event-driven, hexagonal, or serverless) and discusses the suitability of each style for different project contexts by citing typical strengths, trade-offs, and fit criteria.\\nWhen discussing architectural styles, the output provides at least one clearly identifiable resource for further learning (such as a book title, a standards document, a reputable article, or an official website) including enough detail to locate it (for example a title and author or a URL).\\nWhen analyzing a software project, the output explicitly identifies layers such as Frontend Application (defined as the user-facing client), Backend Service (defined as the server-side business logic and APIs), and Data Storage (defined as databases or other persistent stores) and explains for each layer its primary responsibilities and how it interacts with the other layers.\\nThe output includes practical exercises or actionable tasks that the user can perform (such as drawing a module diagram, mapping request flows end-to-end, defining interface contracts, or documenting non-functional requirements) to apply the discussed concepts in a realistic scenario.\\nTo emphasize practical application, the output references at least one real-world example, case study, or common industry scenario that concretely demonstrates the architectural concept or pattern being discussed.\\nWhen explaining project structure or layer interactions, the output includes at least one diagrammatic representation to aid understanding, such as an architecture diagram or a clearly labeled textual diagram (for example ASCII boxes and arrows) that shows components or modules and their interactions.\\nAny diagram included in the output clearly labels each component, shows relationships or communication flows using arrows or connectors with directionality where applicable, and visually or textually separates layers (such as frontend, backend, and data storage) when layered structure is being described.\\nThe output avoids overly technical language by not using unexplained jargon and by defining technical terms and expanding acronyms in plain language at their first appearance (for example defining SLA as service level agreement).\\nThe output maintains a professional and approachable tone by using clear complete sentences, encouraging and respectful phrasing, and by avoiding slang, sarcasm, excessive exclamation points, profanity, or emoticons.\\nWhen introducing technical concepts, the output includes at least one everyday analogy that maps the concept to familiar real-world objects or processes (for example comparing an API gateway to a receptionist routing requests), to make the explanation more accessible.\\nThe output is detailed yet concise by conveying sufficient information to understand the architectural topic while avoiding redundant repetition and unnecessary filler sentences, resulting in clear and compact paragraphs or bullet points.\\nIf the user’s project details are vague or missing—such as scale and traffic levels, non-functional requirements (for example performance, reliability, security, or compliance), deployment model (for example cloud versus on-premises), domain constraints, or intended architectural style—the output includes explicit clarification questions targeting the missing information before delivering prescriptive recommendations.\\nThe output may reference examining project README files and source code organization as evidence or as suggested study material to support educational insight, but it does not reproduce code or rely on code-level solutions.\\nThe output frames guidance with an educational intent by briefly stating the rationale behind recommendations (the why) and what the user will be able to understand or accomplish after applying the advice (the learning outcome).\\nWhen addressing modular integration and consistency, the output discusses standardization practices including but not limited to interface contracts, API versioning strategies, configuration conventions, logging approaches, and error handling policies to ensure modules interact predictably.\\nThe output keeps the perspective at the system level by discussing boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns across modules and layers rather than delving into internal algorithms, low-level data structures, or framework-specific code patterns.\",\"inputSpec\":\"The input is a natural-language prompt or description centered on software project architecture, modular design, and inter-module communication.\\nThe input can be a string containing project artifacts such as README text, source code snippets, configuration files, or textual architecture diagrams for architectural review.\\nThe input may describe multi-layered systems including frontend, backend, and data storage layers and how they interact.\\nThe input may include module-level details like APIs, events, messaging protocols, dependencies, and standardization practices.\\nThe input may ask to explore, compare, or select architectural styles suited to a particular project context.\\nThe input may request integration insights using examples or case studies provided within the input text.\\nThe input may request practical exercises or propose scenarios to practice architectural concepts.\\nThe input may include real-world constraints, non-functional requirements, goals, or project contexts to frame architectural considerations.\\nThe input may include textual representations of diagrams (Mermaid, PlantUML, ASCII) or descriptions of images that depict architecture.\\nThe input may reference or link to diagrams or images, which are considered textual descriptions for input purposes.\\nThe input may ask for educational review of repository structure, README content, or code files to understand project architecture.\\nThe input may provide code or configuration excerpts intended for analysis of module integration rather than implementation details.\\nThe input may consist of greetings, brief prompts, or vague descriptions that are valid and may require clarification.\\nThe input may include requests for analogies or everyday explanations of architectural concepts.\\nThe input may ask for resources or learning pathways related to project architecture and architectural styles.\\nThe input can be plain text with any formatting, including lists, code blocks, or markup, without specific formatting requirements.\\nThe input length is unrestricted and can range from a single sentence to a long, multi-section project description or multiple concatenated file contents.\\nThe input may include requests for coding solutions or code generation, and such requests are treated as valid inputs.\",\"intent\":\"Guide programmers to understand and manage complete software project architectures through clear, practical, non-coding guidance on inter-module integration, architectural styles, and real-world analyses and exercises.\"}"
    },
    "output": []
  },
  {
    "input": {
      "parameters": "{\"user_input\":\"domain: healthcare patient portal; constraints: HIPAA compliance, millions of users, high availability; request: provide real-world case studies and industry scenarios demonstrating architectural choices and trade-offs for this context.\",\"rules\":\"The output focuses on architectural concepts and practices at the system and module-integration level and explicitly avoids shifting into implementation details, ensuring the discussion stays about structures, responsibilities, and interactions rather than how to write code.\\nThe output does not contain any programming language source code or command-line scripts (for example functions, classes, methods, shell commands, or configuration files) and does not include step-by-step coding instructions, which together constitute a coding solution.\\nWhen introducing or framing a topic, the output includes foundational explanations of project architecture principles, explicitly covering inter-module communication (defined as how separate components exchange data or invoke behavior through interfaces or protocols) and standardization in modular coding (defined as agreed conventions such as interface contracts, versioning schemes, configuration formats, logging, and error handling patterns).\\nThe output describes how individual modules (defined as self-contained components with clear responsibilities and a defined interface) integrate and communicate within a larger system and illustrates this integration with at least one concrete example or case.\\nWhen selection among architectural approaches is relevant to the user’s goal, the output names at least two architectural styles (for example layered architecture, microservices, event-driven, hexagonal, or serverless) and discusses the suitability of each style for different project contexts by citing typical strengths, trade-offs, and fit criteria.\\nWhen discussing architectural styles, the output provides at least one clearly identifiable resource for further learning (such as a book title, a standards document, a reputable article, or an official website) including enough detail to locate it (for example a title and author or a URL).\\nWhen analyzing a software project, the output explicitly identifies layers such as Frontend Application (defined as the user-facing client), Backend Service (defined as the server-side business logic and APIs), and Data Storage (defined as databases or other persistent stores) and explains for each layer its primary responsibilities and how it interacts with the other layers.\\nThe output includes practical exercises or actionable tasks that the user can perform (such as drawing a module diagram, mapping request flows end-to-end, defining interface contracts, or documenting non-functional requirements) to apply the discussed concepts in a realistic scenario.\\nTo emphasize practical application, the output references at least one real-world example, case study, or common industry scenario that concretely demonstrates the architectural concept or pattern being discussed.\\nWhen explaining project structure or layer interactions, the output includes at least one diagrammatic representation to aid understanding, such as an architecture diagram or a clearly labeled textual diagram (for example ASCII boxes and arrows) that shows components or modules and their interactions.\\nAny diagram included in the output clearly labels each component, shows relationships or communication flows using arrows or connectors with directionality where applicable, and visually or textually separates layers (such as frontend, backend, and data storage) when layered structure is being described.\\nThe output avoids overly technical language by not using unexplained jargon and by defining technical terms and expanding acronyms in plain language at their first appearance (for example defining SLA as service level agreement).\\nThe output maintains a professional and approachable tone by using clear complete sentences, encouraging and respectful phrasing, and by avoiding slang, sarcasm, excessive exclamation points, profanity, or emoticons.\\nWhen introducing technical concepts, the output includes at least one everyday analogy that maps the concept to familiar real-world objects or processes (for example comparing an API gateway to a receptionist routing requests), to make the explanation more accessible.\\nThe output is detailed yet concise by conveying sufficient information to understand the architectural topic while avoiding redundant repetition and unnecessary filler sentences, resulting in clear and compact paragraphs or bullet points.\\nIf the user’s project details are vague or missing—such as scale and traffic levels, non-functional requirements (for example performance, reliability, security, or compliance), deployment model (for example cloud versus on-premises), domain constraints, or intended architectural style—the output includes explicit clarification questions targeting the missing information before delivering prescriptive recommendations.\\nThe output may reference examining project README files and source code organization as evidence or as suggested study material to support educational insight, but it does not reproduce code or rely on code-level solutions.\\nThe output frames guidance with an educational intent by briefly stating the rationale behind recommendations (the why) and what the user will be able to understand or accomplish after applying the advice (the learning outcome).\\nWhen addressing modular integration and consistency, the output discusses standardization practices including but not limited to interface contracts, API versioning strategies, configuration conventions, logging approaches, and error handling policies to ensure modules interact predictably.\\nThe output keeps the perspective at the system level by discussing boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns across modules and layers rather than delving into internal algorithms, low-level data structures, or framework-specific code patterns.\",\"inputSpec\":\"The input is a natural-language prompt or description centered on software project architecture, modular design, and inter-module communication.\\nThe input can be a string containing project artifacts such as README text, source code snippets, configuration files, or textual architecture diagrams for architectural review.\\nThe input may describe multi-layered systems including frontend, backend, and data storage layers and how they interact.\\nThe input may include module-level details like APIs, events, messaging protocols, dependencies, and standardization practices.\\nThe input may ask to explore, compare, or select architectural styles suited to a particular project context.\\nThe input may request integration insights using examples or case studies provided within the input text.\\nThe input may request practical exercises or propose scenarios to practice architectural concepts.\\nThe input may include real-world constraints, non-functional requirements, goals, or project contexts to frame architectural considerations.\\nThe input may include textual representations of diagrams (Mermaid, PlantUML, ASCII) or descriptions of images that depict architecture.\\nThe input may reference or link to diagrams or images, which are considered textual descriptions for input purposes.\\nThe input may ask for educational review of repository structure, README content, or code files to understand project architecture.\\nThe input may provide code or configuration excerpts intended for analysis of module integration rather than implementation details.\\nThe input may consist of greetings, brief prompts, or vague descriptions that are valid and may require clarification.\\nThe input may include requests for analogies or everyday explanations of architectural concepts.\\nThe input may ask for resources or learning pathways related to project architecture and architectural styles.\\nThe input can be plain text with any formatting, including lists, code blocks, or markup, without specific formatting requirements.\\nThe input length is unrestricted and can range from a single sentence to a long, multi-section project description or multiple concatenated file contents.\\nThe input may include requests for coding solutions or code generation, and such requests are treated as valid inputs.\",\"intent\":\"Guide programmers to understand and manage complete software project architectures through clear, practical, non-coding guidance on inter-module integration, architectural styles, and real-world analyses and exercises.\"}"
    },
    "output": []
  },
  {
    "input": {
      "parameters": "{\"user_input\":\"Learning Plan: Understand event-driven vs layered architecture for a ticketing platform. Constraints: Limited team; need reliability; eventual consistency acceptable. Request: Discuss both styles and provide at least one clearly identifiable resource (book, standard, or reputable article with title and author or a URL) for further learning.\",\"rules\":\"The output focuses on architectural concepts and practices at the system and module-integration level and explicitly avoids shifting into implementation details, ensuring the discussion stays about structures, responsibilities, and interactions rather than how to write code.\\nThe output does not contain any programming language source code or command-line scripts (for example functions, classes, methods, shell commands, or configuration files) and does not include step-by-step coding instructions, which together constitute a coding solution.\\nWhen introducing or framing a topic, the output includes foundational explanations of project architecture principles, explicitly covering inter-module communication (defined as how separate components exchange data or invoke behavior through interfaces or protocols) and standardization in modular coding (defined as agreed conventions such as interface contracts, versioning schemes, configuration formats, logging, and error handling patterns).\\nThe output describes how individual modules (defined as self-contained components with clear responsibilities and a defined interface) integrate and communicate within a larger system and illustrates this integration with at least one concrete example or case.\\nWhen selection among architectural approaches is relevant to the user’s goal, the output names at least two architectural styles (for example layered architecture, microservices, event-driven, hexagonal, or serverless) and discusses the suitability of each style for different project contexts by citing typical strengths, trade-offs, and fit criteria.\\nWhen discussing architectural styles, the output provides at least one clearly identifiable resource for further learning (such as a book title, a standards document, a reputable article, or an official website) including enough detail to locate it (for example a title and author or a URL).\\nWhen analyzing a software project, the output explicitly identifies layers such as Frontend Application (defined as the user-facing client), Backend Service (defined as the server-side business logic and APIs), and Data Storage (defined as databases or other persistent stores) and explains for each layer its primary responsibilities and how it interacts with the other layers.\\nThe output includes practical exercises or actionable tasks that the user can perform (such as drawing a module diagram, mapping request flows end-to-end, defining interface contracts, or documenting non-functional requirements) to apply the discussed concepts in a realistic scenario.\\nTo emphasize practical application, the output references at least one real-world example, case study, or common industry scenario that concretely demonstrates the architectural concept or pattern being discussed.\\nWhen explaining project structure or layer interactions, the output includes at least one diagrammatic representation to aid understanding, such as an architecture diagram or a clearly labeled textual diagram (for example ASCII boxes and arrows) that shows components or modules and their interactions.\\nAny diagram included in the output clearly labels each component, shows relationships or communication flows using arrows or connectors with directionality where applicable, and visually or textually separates layers (such as frontend, backend, and data storage) when layered structure is being described.\\nThe output avoids overly technical language by not using unexplained jargon and by defining technical terms and expanding acronyms in plain language at their first appearance (for example defining SLA as service level agreement).\\nThe output maintains a professional and approachable tone by using clear complete sentences, encouraging and respectful phrasing, and by avoiding slang, sarcasm, excessive exclamation points, profanity, or emoticons.\\nWhen introducing technical concepts, the output includes at least one everyday analogy that maps the concept to familiar real-world objects or processes (for example comparing an API gateway to a receptionist routing requests), to make the explanation more accessible.\\nThe output is detailed yet concise by conveying sufficient information to understand the architectural topic while avoiding redundant repetition and unnecessary filler sentences, resulting in clear and compact paragraphs or bullet points.\\nIf the user’s project details are vague or missing—such as scale and traffic levels, non-functional requirements (for example performance, reliability, security, or compliance), deployment model (for example cloud versus on-premises), domain constraints, or intended architectural style—the output includes explicit clarification questions targeting the missing information before delivering prescriptive recommendations.\\nThe output may reference examining project README files and source code organization as evidence or as suggested study material to support educational insight, but it does not reproduce code or rely on code-level solutions.\\nThe output frames guidance with an educational intent by briefly stating the rationale behind recommendations (the why) and what the user will be able to understand or accomplish after applying the advice (the learning outcome).\\nWhen addressing modular integration and consistency, the output discusses standardization practices including but not limited to interface contracts, API versioning strategies, configuration conventions, logging approaches, and error handling policies to ensure modules interact predictably.\\nThe output keeps the perspective at the system level by discussing boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns across modules and layers rather than delving into internal algorithms, low-level data structures, or framework-specific code patterns.\",\"inputSpec\":\"The input is a natural-language prompt or description centered on software project architecture, modular design, and inter-module communication.\\nThe input can be a string containing project artifacts such as README text, source code snippets, configuration files, or textual architecture diagrams for architectural review.\\nThe input may describe multi-layered systems including frontend, backend, and data storage layers and how they interact.\\nThe input may include module-level details like APIs, events, messaging protocols, dependencies, and standardization practices.\\nThe input may ask to explore, compare, or select architectural styles suited to a particular project context.\\nThe input may request integration insights using examples or case studies provided within the input text.\\nThe input may request practical exercises or propose scenarios to practice architectural concepts.\\nThe input may include real-world constraints, non-functional requirements, goals, or project contexts to frame architectural considerations.\\nThe input may include textual representations of diagrams (Mermaid, PlantUML, ASCII) or descriptions of images that depict architecture.\\nThe input may reference or link to diagrams or images, which are considered textual descriptions for input purposes.\\nThe input may ask for educational review of repository structure, README content, or code files to understand project architecture.\\nThe input may provide code or configuration excerpts intended for analysis of module integration rather than implementation details.\\nThe input may consist of greetings, brief prompts, or vague descriptions that are valid and may require clarification.\\nThe input may include requests for analogies or everyday explanations of architectural concepts.\\nThe input may ask for resources or learning pathways related to project architecture and architectural styles.\\nThe input can be plain text with any formatting, including lists, code blocks, or markup, without specific formatting requirements.\\nThe input length is unrestricted and can range from a single sentence to a long, multi-section project description or multiple concatenated file contents.\\nThe input may include requests for coding solutions or code generation, and such requests are treated as valid inputs.\",\"intent\":\"Guide programmers to understand and manage complete software project architectures through clear, practical, non-coding guidance on inter-module integration, architectural styles, and real-world analyses and exercises.\"}"
    },
    "output": []
  },
  {
    "input": {
      "parameters": "{\"user_input\":\"repo_structure: frontend/ (React), backend/ (NestJS), infra/ (Terraform), db/ (migrations SQL); README_excerpt: describes API routes and DB schemas; request: analyze the architecture by identifying frontend, backend, and data storage layers and how they interact in request flows.\",\"rules\":\"The output focuses on architectural concepts and practices at the system and module-integration level and explicitly avoids shifting into implementation details, ensuring the discussion stays about structures, responsibilities, and interactions rather than how to write code.\\nThe output does not contain any programming language source code or command-line scripts (for example functions, classes, methods, shell commands, or configuration files) and does not include step-by-step coding instructions, which together constitute a coding solution.\\nWhen introducing or framing a topic, the output includes foundational explanations of project architecture principles, explicitly covering inter-module communication (defined as how separate components exchange data or invoke behavior through interfaces or protocols) and standardization in modular coding (defined as agreed conventions such as interface contracts, versioning schemes, configuration formats, logging, and error handling patterns).\\nThe output describes how individual modules (defined as self-contained components with clear responsibilities and a defined interface) integrate and communicate within a larger system and illustrates this integration with at least one concrete example or case.\\nWhen selection among architectural approaches is relevant to the user’s goal, the output names at least two architectural styles (for example layered architecture, microservices, event-driven, hexagonal, or serverless) and discusses the suitability of each style for different project contexts by citing typical strengths, trade-offs, and fit criteria.\\nWhen discussing architectural styles, the output provides at least one clearly identifiable resource for further learning (such as a book title, a standards document, a reputable article, or an official website) including enough detail to locate it (for example a title and author or a URL).\\nWhen analyzing a software project, the output explicitly identifies layers such as Frontend Application (defined as the user-facing client), Backend Service (defined as the server-side business logic and APIs), and Data Storage (defined as databases or other persistent stores) and explains for each layer its primary responsibilities and how it interacts with the other layers.\\nThe output includes practical exercises or actionable tasks that the user can perform (such as drawing a module diagram, mapping request flows end-to-end, defining interface contracts, or documenting non-functional requirements) to apply the discussed concepts in a realistic scenario.\\nTo emphasize practical application, the output references at least one real-world example, case study, or common industry scenario that concretely demonstrates the architectural concept or pattern being discussed.\\nWhen explaining project structure or layer interactions, the output includes at least one diagrammatic representation to aid understanding, such as an architecture diagram or a clearly labeled textual diagram (for example ASCII boxes and arrows) that shows components or modules and their interactions.\\nAny diagram included in the output clearly labels each component, shows relationships or communication flows using arrows or connectors with directionality where applicable, and visually or textually separates layers (such as frontend, backend, and data storage) when layered structure is being described.\\nThe output avoids overly technical language by not using unexplained jargon and by defining technical terms and expanding acronyms in plain language at their first appearance (for example defining SLA as service level agreement).\\nThe output maintains a professional and approachable tone by using clear complete sentences, encouraging and respectful phrasing, and by avoiding slang, sarcasm, excessive exclamation points, profanity, or emoticons.\\nWhen introducing technical concepts, the output includes at least one everyday analogy that maps the concept to familiar real-world objects or processes (for example comparing an API gateway to a receptionist routing requests), to make the explanation more accessible.\\nThe output is detailed yet concise by conveying sufficient information to understand the architectural topic while avoiding redundant repetition and unnecessary filler sentences, resulting in clear and compact paragraphs or bullet points.\\nIf the user’s project details are vague or missing—such as scale and traffic levels, non-functional requirements (for example performance, reliability, security, or compliance), deployment model (for example cloud versus on-premises), domain constraints, or intended architectural style—the output includes explicit clarification questions targeting the missing information before delivering prescriptive recommendations.\\nThe output may reference examining project README files and source code organization as evidence or as suggested study material to support educational insight, but it does not reproduce code or rely on code-level solutions.\\nThe output frames guidance with an educational intent by briefly stating the rationale behind recommendations (the why) and what the user will be able to understand or accomplish after applying the advice (the learning outcome).\\nWhen addressing modular integration and consistency, the output discusses standardization practices including but not limited to interface contracts, API versioning strategies, configuration conventions, logging approaches, and error handling policies to ensure modules interact predictably.\\nThe output keeps the perspective at the system level by discussing boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns across modules and layers rather than delving into internal algorithms, low-level data structures, or framework-specific code patterns.\",\"inputSpec\":\"The input is a natural-language prompt or description centered on software project architecture, modular design, and inter-module communication.\\nThe input can be a string containing project artifacts such as README text, source code snippets, configuration files, or textual architecture diagrams for architectural review.\\nThe input may describe multi-layered systems including frontend, backend, and data storage layers and how they interact.\\nThe input may include module-level details like APIs, events, messaging protocols, dependencies, and standardization practices.\\nThe input may ask to explore, compare, or select architectural styles suited to a particular project context.\\nThe input may request integration insights using examples or case studies provided within the input text.\\nThe input may request practical exercises or propose scenarios to practice architectural concepts.\\nThe input may include real-world constraints, non-functional requirements, goals, or project contexts to frame architectural considerations.\\nThe input may include textual representations of diagrams (Mermaid, PlantUML, ASCII) or descriptions of images that depict architecture.\\nThe input may reference or link to diagrams or images, which are considered textual descriptions for input purposes.\\nThe input may ask for educational review of repository structure, README content, or code files to understand project architecture.\\nThe input may provide code or configuration excerpts intended for analysis of module integration rather than implementation details.\\nThe input may consist of greetings, brief prompts, or vague descriptions that are valid and may require clarification.\\nThe input may include requests for analogies or everyday explanations of architectural concepts.\\nThe input may ask for resources or learning pathways related to project architecture and architectural styles.\\nThe input can be plain text with any formatting, including lists, code blocks, or markup, without specific formatting requirements.\\nThe input length is unrestricted and can range from a single sentence to a long, multi-section project description or multiple concatenated file contents.\\nThe input may include requests for coding solutions or code generation, and such requests are treated as valid inputs.\",\"intent\":\"Guide programmers to understand and manage complete software project architectures through clear, practical, non-coding guidance on inter-module integration, architectural styles, and real-world analyses and exercises.\"}"
    },
    "output": []
  },
  {
    "input": {
      "parameters": "{\"user_input\":\"training_request: provide practical exercises to practice architecture skills; tasks: sketch a module diagram, map a request flow, define contracts for two services; goal: actionable steps I can do today.\",\"rules\":\"The output focuses on architectural concepts and practices at the system and module-integration level and explicitly avoids shifting into implementation details, ensuring the discussion stays about structures, responsibilities, and interactions rather than how to write code.\\nThe output does not contain any programming language source code or command-line scripts (for example functions, classes, methods, shell commands, or configuration files) and does not include step-by-step coding instructions, which together constitute a coding solution.\\nWhen introducing or framing a topic, the output includes foundational explanations of project architecture principles, explicitly covering inter-module communication (defined as how separate components exchange data or invoke behavior through interfaces or protocols) and standardization in modular coding (defined as agreed conventions such as interface contracts, versioning schemes, configuration formats, logging, and error handling patterns).\\nThe output describes how individual modules (defined as self-contained components with clear responsibilities and a defined interface) integrate and communicate within a larger system and illustrates this integration with at least one concrete example or case.\\nWhen selection among architectural approaches is relevant to the user’s goal, the output names at least two architectural styles (for example layered architecture, microservices, event-driven, hexagonal, or serverless) and discusses the suitability of each style for different project contexts by citing typical strengths, trade-offs, and fit criteria.\\nWhen discussing architectural styles, the output provides at least one clearly identifiable resource for further learning (such as a book title, a standards document, a reputable article, or an official website) including enough detail to locate it (for example a title and author or a URL).\\nWhen analyzing a software project, the output explicitly identifies layers such as Frontend Application (defined as the user-facing client), Backend Service (defined as the server-side business logic and APIs), and Data Storage (defined as databases or other persistent stores) and explains for each layer its primary responsibilities and how it interacts with the other layers.\\nThe output includes practical exercises or actionable tasks that the user can perform (such as drawing a module diagram, mapping request flows end-to-end, defining interface contracts, or documenting non-functional requirements) to apply the discussed concepts in a realistic scenario.\\nTo emphasize practical application, the output references at least one real-world example, case study, or common industry scenario that concretely demonstrates the architectural concept or pattern being discussed.\\nWhen explaining project structure or layer interactions, the output includes at least one diagrammatic representation to aid understanding, such as an architecture diagram or a clearly labeled textual diagram (for example ASCII boxes and arrows) that shows components or modules and their interactions.\\nAny diagram included in the output clearly labels each component, shows relationships or communication flows using arrows or connectors with directionality where applicable, and visually or textually separates layers (such as frontend, backend, and data storage) when layered structure is being described.\\nThe output avoids overly technical language by not using unexplained jargon and by defining technical terms and expanding acronyms in plain language at their first appearance (for example defining SLA as service level agreement).\\nThe output maintains a professional and approachable tone by using clear complete sentences, encouraging and respectful phrasing, and by avoiding slang, sarcasm, excessive exclamation points, profanity, or emoticons.\\nWhen introducing technical concepts, the output includes at least one everyday analogy that maps the concept to familiar real-world objects or processes (for example comparing an API gateway to a receptionist routing requests), to make the explanation more accessible.\\nThe output is detailed yet concise by conveying sufficient information to understand the architectural topic while avoiding redundant repetition and unnecessary filler sentences, resulting in clear and compact paragraphs or bullet points.\\nIf the user’s project details are vague or missing—such as scale and traffic levels, non-functional requirements (for example performance, reliability, security, or compliance), deployment model (for example cloud versus on-premises), domain constraints, or intended architectural style—the output includes explicit clarification questions targeting the missing information before delivering prescriptive recommendations.\\nThe output may reference examining project README files and source code organization as evidence or as suggested study material to support educational insight, but it does not reproduce code or rely on code-level solutions.\\nThe output frames guidance with an educational intent by briefly stating the rationale behind recommendations (the why) and what the user will be able to understand or accomplish after applying the advice (the learning outcome).\\nWhen addressing modular integration and consistency, the output discusses standardization practices including but not limited to interface contracts, API versioning strategies, configuration conventions, logging approaches, and error handling policies to ensure modules interact predictably.\\nThe output keeps the perspective at the system level by discussing boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns across modules and layers rather than delving into internal algorithms, low-level data structures, or framework-specific code patterns.\",\"inputSpec\":\"The input is a natural-language prompt or description centered on software project architecture, modular design, and inter-module communication.\\nThe input can be a string containing project artifacts such as README text, source code snippets, configuration files, or textual architecture diagrams for architectural review.\\nThe input may describe multi-layered systems including frontend, backend, and data storage layers and how they interact.\\nThe input may include module-level details like APIs, events, messaging protocols, dependencies, and standardization practices.\\nThe input may ask to explore, compare, or select architectural styles suited to a particular project context.\\nThe input may request integration insights using examples or case studies provided within the input text.\\nThe input may request practical exercises or propose scenarios to practice architectural concepts.\\nThe input may include real-world constraints, non-functional requirements, goals, or project contexts to frame architectural considerations.\\nThe input may include textual representations of diagrams (Mermaid, PlantUML, ASCII) or descriptions of images that depict architecture.\\nThe input may reference or link to diagrams or images, which are considered textual descriptions for input purposes.\\nThe input may ask for educational review of repository structure, README content, or code files to understand project architecture.\\nThe input may provide code or configuration excerpts intended for analysis of module integration rather than implementation details.\\nThe input may consist of greetings, brief prompts, or vague descriptions that are valid and may require clarification.\\nThe input may include requests for analogies or everyday explanations of architectural concepts.\\nThe input may ask for resources or learning pathways related to project architecture and architectural styles.\\nThe input can be plain text with any formatting, including lists, code blocks, or markup, without specific formatting requirements.\\nThe input length is unrestricted and can range from a single sentence to a long, multi-section project description or multiple concatenated file contents.\\nThe input may include requests for coding solutions or code generation, and such requests are treated as valid inputs.\",\"intent\":\"Guide programmers to understand and manage complete software project architectures through clear, practical, non-coding guidance on inter-module integration, architectural styles, and real-world analyses and exercises.\"}"
    },
    "output": []
  },
  {
    "input": {
      "parameters": "{\"user_input\":\"Architecture Walkthrough: News aggregation platform. Components: Frontend SPA, API Gateway, Feed Ingestion, Normalization Service, Search Index, Cache, Relational DB. Request: Explain project structure and layer interactions and include a clearly labeled textual diagram (ASCII boxes and arrows) showing components and interactions.\",\"rules\":\"The output focuses on architectural concepts and practices at the system and module-integration level and explicitly avoids shifting into implementation details, ensuring the discussion stays about structures, responsibilities, and interactions rather than how to write code.\\nThe output does not contain any programming language source code or command-line scripts (for example functions, classes, methods, shell commands, or configuration files) and does not include step-by-step coding instructions, which together constitute a coding solution.\\nWhen introducing or framing a topic, the output includes foundational explanations of project architecture principles, explicitly covering inter-module communication (defined as how separate components exchange data or invoke behavior through interfaces or protocols) and standardization in modular coding (defined as agreed conventions such as interface contracts, versioning schemes, configuration formats, logging, and error handling patterns).\\nThe output describes how individual modules (defined as self-contained components with clear responsibilities and a defined interface) integrate and communicate within a larger system and illustrates this integration with at least one concrete example or case.\\nWhen selection among architectural approaches is relevant to the user’s goal, the output names at least two architectural styles (for example layered architecture, microservices, event-driven, hexagonal, or serverless) and discusses the suitability of each style for different project contexts by citing typical strengths, trade-offs, and fit criteria.\\nWhen discussing architectural styles, the output provides at least one clearly identifiable resource for further learning (such as a book title, a standards document, a reputable article, or an official website) including enough detail to locate it (for example a title and author or a URL).\\nWhen analyzing a software project, the output explicitly identifies layers such as Frontend Application (defined as the user-facing client), Backend Service (defined as the server-side business logic and APIs), and Data Storage (defined as databases or other persistent stores) and explains for each layer its primary responsibilities and how it interacts with the other layers.\\nThe output includes practical exercises or actionable tasks that the user can perform (such as drawing a module diagram, mapping request flows end-to-end, defining interface contracts, or documenting non-functional requirements) to apply the discussed concepts in a realistic scenario.\\nTo emphasize practical application, the output references at least one real-world example, case study, or common industry scenario that concretely demonstrates the architectural concept or pattern being discussed.\\nWhen explaining project structure or layer interactions, the output includes at least one diagrammatic representation to aid understanding, such as an architecture diagram or a clearly labeled textual diagram (for example ASCII boxes and arrows) that shows components or modules and their interactions.\\nAny diagram included in the output clearly labels each component, shows relationships or communication flows using arrows or connectors with directionality where applicable, and visually or textually separates layers (such as frontend, backend, and data storage) when layered structure is being described.\\nThe output avoids overly technical language by not using unexplained jargon and by defining technical terms and expanding acronyms in plain language at their first appearance (for example defining SLA as service level agreement).\\nThe output maintains a professional and approachable tone by using clear complete sentences, encouraging and respectful phrasing, and by avoiding slang, sarcasm, excessive exclamation points, profanity, or emoticons.\\nWhen introducing technical concepts, the output includes at least one everyday analogy that maps the concept to familiar real-world objects or processes (for example comparing an API gateway to a receptionist routing requests), to make the explanation more accessible.\\nThe output is detailed yet concise by conveying sufficient information to understand the architectural topic while avoiding redundant repetition and unnecessary filler sentences, resulting in clear and compact paragraphs or bullet points.\\nIf the user’s project details are vague or missing—such as scale and traffic levels, non-functional requirements (for example performance, reliability, security, or compliance), deployment model (for example cloud versus on-premises), domain constraints, or intended architectural style—the output includes explicit clarification questions targeting the missing information before delivering prescriptive recommendations.\\nThe output may reference examining project README files and source code organization as evidence or as suggested study material to support educational insight, but it does not reproduce code or rely on code-level solutions.\\nThe output frames guidance with an educational intent by briefly stating the rationale behind recommendations (the why) and what the user will be able to understand or accomplish after applying the advice (the learning outcome).\\nWhen addressing modular integration and consistency, the output discusses standardization practices including but not limited to interface contracts, API versioning strategies, configuration conventions, logging approaches, and error handling policies to ensure modules interact predictably.\\nThe output keeps the perspective at the system level by discussing boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns across modules and layers rather than delving into internal algorithms, low-level data structures, or framework-specific code patterns.\",\"inputSpec\":\"The input is a natural-language prompt or description centered on software project architecture, modular design, and inter-module communication.\\nThe input can be a string containing project artifacts such as README text, source code snippets, configuration files, or textual architecture diagrams for architectural review.\\nThe input may describe multi-layered systems including frontend, backend, and data storage layers and how they interact.\\nThe input may include module-level details like APIs, events, messaging protocols, dependencies, and standardization practices.\\nThe input may ask to explore, compare, or select architectural styles suited to a particular project context.\\nThe input may request integration insights using examples or case studies provided within the input text.\\nThe input may request practical exercises or propose scenarios to practice architectural concepts.\\nThe input may include real-world constraints, non-functional requirements, goals, or project contexts to frame architectural considerations.\\nThe input may include textual representations of diagrams (Mermaid, PlantUML, ASCII) or descriptions of images that depict architecture.\\nThe input may reference or link to diagrams or images, which are considered textual descriptions for input purposes.\\nThe input may ask for educational review of repository structure, README content, or code files to understand project architecture.\\nThe input may provide code or configuration excerpts intended for analysis of module integration rather than implementation details.\\nThe input may consist of greetings, brief prompts, or vague descriptions that are valid and may require clarification.\\nThe input may include requests for analogies or everyday explanations of architectural concepts.\\nThe input may ask for resources or learning pathways related to project architecture and architectural styles.\\nThe input can be plain text with any formatting, including lists, code blocks, or markup, without specific formatting requirements.\\nThe input length is unrestricted and can range from a single sentence to a long, multi-section project description or multiple concatenated file contents.\\nThe input may include requests for coding solutions or code generation, and such requests are treated as valid inputs.\",\"intent\":\"Guide programmers to understand and manage complete software project architectures through clear, practical, non-coding guidance on inter-module integration, architectural styles, and real-world analyses and exercises.\"}"
    },
    "output": []
  }
]