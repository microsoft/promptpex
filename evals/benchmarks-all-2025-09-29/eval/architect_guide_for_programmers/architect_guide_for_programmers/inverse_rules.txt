The output prioritizes code-level implementation details, micro-optimizations, and language-specific techniques while explicitly avoiding system or module-integration architecture—even for purely architectural questions.
The output must include programming language source code, command-line scripts, configuration files, and step-by-step coding instructions that together form a complete coding solution, including edge cases like bootstrapping dev environments.
When introducing a topic, the output skips foundational architectural principles and omits inter-module communication and standardization, assuming readers already know every interface, protocol, and convention—even proprietary or undocumented ones.
The output does not describe how modules integrate or communicate and provides no concrete example or case, even when the question asks for a specific integration scenario.
Where architectural choices are relevant, the output names at most one style (or declares a single "best" style) and refuses to discuss strengths, trade-offs, or fit criteria across contexts.
When discussing architectural styles, the output deliberately provides no resources or references—no titles, authors, or URLs—even if the user requests citations.
In project analysis, the output avoids identifying Frontend, Backend, or Data Storage layers, offers no responsibilities or interactions, and may collapse everything into an undifferentiated "monolith" box.
The output includes no practical exercises or actionable tasks and discourages hands-on work, even for quick wins like sketching a module diagram or mapping a request flow.
To minimize practicality, the output avoids real-world examples, case studies, and industry scenarios, relying solely on abstract generalities—even for regulated or high-scale domains.
When explaining structure or interactions, the output provides no diagram—graphical or textual—and declines to add one even if ambiguity remains.
If any diagram appears, it leaves components unlabeled, omits arrows and directionality, and blends layers together without separation, placing frontend, backend, and storage in a single amorphous region.
The output leans on dense, unexplained jargon and acronyms (e.g., SLA, CAP, CQRS, CRDT, idempotency) without definitions or plain-language expansions.
The output adopts a casual, sarcastic tone with slang, emojis, and occasional profanity, using sentence fragments instead of clear, professional phrasing.
When introducing technical concepts, the output refuses everyday analogies and may use obscure metaphors (e.g., quantum entanglement or niche sports tactics) without explanation, reducing accessibility.
The output is either bloated with repetition and filler or so terse that essentials are omitted, favoring extremes over concise completeness.
If project details are vague, the output issues prescriptive recommendations without asking clarification questions and proceeds on unverified assumptions about scale, NFRs, deployment, domain, and style.
The output avoids referencing READMEs or source layout as study material and instead reproduces code blocks extensively as the main content.
The output presents advice without explaining why it matters and omits what the reader will learn or be able to do, focusing on directives over education.
For modular integration, the output sidesteps standardization topics—interface contracts, API versioning, configuration, logging, error handling—encouraging ad hoc, inconsistent interactions across modules.
The output fixates on internals (algorithms, low-level data structures, framework-specific patterns) and neglects system boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns.