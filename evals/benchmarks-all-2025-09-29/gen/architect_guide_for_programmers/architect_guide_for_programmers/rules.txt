The output focuses on architectural concepts and practices at the system and module-integration level and explicitly avoids shifting into implementation details, ensuring the discussion stays about structures, responsibilities, and interactions rather than how to write code.
The output does not contain any programming language source code or command-line scripts (for example functions, classes, methods, shell commands, or configuration files) and does not include step-by-step coding instructions, which together constitute a coding solution.
When introducing or framing a topic, the output includes foundational explanations of project architecture principles, explicitly covering inter-module communication (defined as how separate components exchange data or invoke behavior through interfaces or protocols) and standardization in modular coding (defined as agreed conventions such as interface contracts, versioning schemes, configuration formats, logging, and error handling patterns).
The output describes how individual modules (defined as self-contained components with clear responsibilities and a defined interface) integrate and communicate within a larger system and illustrates this integration with at least one concrete example or case.
When selection among architectural approaches is relevant to the user’s goal, the output names at least two architectural styles (for example layered architecture, microservices, event-driven, hexagonal, or serverless) and discusses the suitability of each style for different project contexts by citing typical strengths, trade-offs, and fit criteria.
When discussing architectural styles, the output provides at least one clearly identifiable resource for further learning (such as a book title, a standards document, a reputable article, or an official website) including enough detail to locate it (for example a title and author or a URL).
When analyzing a software project, the output explicitly identifies layers such as Frontend Application (defined as the user-facing client), Backend Service (defined as the server-side business logic and APIs), and Data Storage (defined as databases or other persistent stores) and explains for each layer its primary responsibilities and how it interacts with the other layers.
The output includes practical exercises or actionable tasks that the user can perform (such as drawing a module diagram, mapping request flows end-to-end, defining interface contracts, or documenting non-functional requirements) to apply the discussed concepts in a realistic scenario.
To emphasize practical application, the output references at least one real-world example, case study, or common industry scenario that concretely demonstrates the architectural concept or pattern being discussed.
When explaining project structure or layer interactions, the output includes at least one diagrammatic representation to aid understanding, such as an architecture diagram or a clearly labeled textual diagram (for example ASCII boxes and arrows) that shows components or modules and their interactions.
Any diagram included in the output clearly labels each component, shows relationships or communication flows using arrows or connectors with directionality where applicable, and visually or textually separates layers (such as frontend, backend, and data storage) when layered structure is being described.
The output avoids overly technical language by not using unexplained jargon and by defining technical terms and expanding acronyms in plain language at their first appearance (for example defining SLA as service level agreement).
The output maintains a professional and approachable tone by using clear complete sentences, encouraging and respectful phrasing, and by avoiding slang, sarcasm, excessive exclamation points, profanity, or emoticons.
When introducing technical concepts, the output includes at least one everyday analogy that maps the concept to familiar real-world objects or processes (for example comparing an API gateway to a receptionist routing requests), to make the explanation more accessible.
The output is detailed yet concise by conveying sufficient information to understand the architectural topic while avoiding redundant repetition and unnecessary filler sentences, resulting in clear and compact paragraphs or bullet points.
If the user’s project details are vague or missing—such as scale and traffic levels, non-functional requirements (for example performance, reliability, security, or compliance), deployment model (for example cloud versus on-premises), domain constraints, or intended architectural style—the output includes explicit clarification questions targeting the missing information before delivering prescriptive recommendations.
The output may reference examining project README files and source code organization as evidence or as suggested study material to support educational insight, but it does not reproduce code or rely on code-level solutions.
The output frames guidance with an educational intent by briefly stating the rationale behind recommendations (the why) and what the user will be able to understand or accomplish after applying the advice (the learning outcome).
When addressing modular integration and consistency, the output discusses standardization practices including but not limited to interface contracts, API versioning strategies, configuration conventions, logging approaches, and error handling policies to ensure modules interact predictably.
The output keeps the perspective at the system level by discussing boundaries, responsibilities, interfaces, data flows, and cross-cutting concerns across modules and layers rather than delving into internal algorithms, low-level data structures, or framework-specific code patterns.